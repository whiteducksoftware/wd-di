{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WD-DI: .NET Style Dependency Injection for Python \ud83d\udc0d","text":"<p>WD-DI is a lightweight dependency injection library for Python inspired by .NET's DI system. It provides a robust and flexible way to manage dependencies and lifetimes in your applications. For the Python purists: WD-DI needs no external libraries, just Python standard libraries!  purity \u2728</p> <p>This documentation will guide you \ud83d\uddfa\ufe0f through installing WD-DI, understanding its core concepts, and leveraging its advanced features to build well-structured and maintainable Python applications.</p>"},{"location":"#features-overview","title":"Features Overview \ud83d\ude80","text":"<p>WD-DI supports a variety of dependency injection patterns and configurations, including:</p> <ul> <li>Service Lifetimes: Control how instances are created and shared (Transient \u23f3, Singleton \ud83c\udf0d, Scoped \ud83c\udfaf).</li> <li>Constructor Injection: Automatically resolve and inject dependencies into your services \ud83d\udee0\ufe0f.</li> <li>Configuration Binding: Strongly-typed options pattern for managing application settings \u2699\ufe0f.</li> <li>Middleware Pipelines: Compose processing logic for cross-cutting concerns \ud83d\udd17.</li> <li>Scoped Service Management: Explicit scope creation and automatic disposal of resources \ud83d\uddd1\ufe0f.</li> <li>Instance Registration: Register pre-created objects with the DI container \ud83d\udce6.</li> <li>Circular Dependency Detection: Safeguards against infinite recursion in your dependency graph \ud83d\udd04.</li> </ul> <p>Each feature is designed to promote clear, testable, and maintainable code. Detailed explanations and examples for these can be found in the Core Concepts, Middleware, and Advanced Features sections.</p>"},{"location":"#why-use-dependency-injection","title":"Why Use Dependency Injection? \ud83e\udd14","text":"<p>Dependency Injection (DI) is a design pattern that allows for the creation of loosely coupled components. Instead of components creating their own dependencies, they are \"injected\" from an external source (the DI container). This leads to:</p> <ul> <li>Improved Testability: Dependencies can be easily mocked or stubbed in unit tests \ud83e\uddea.</li> <li>Enhanced Modularity: Components are more independent and easier to replace or reconfigure \ud83e\udde9.</li> <li>Better Code Organization: Clear separation of concerns and responsibilities \ud83d\uddc2\ufe0f.</li> <li>Increased Flexibility: Easier to manage complex object lifecycles and configurations \ud83e\udd38.</li> </ul> <p>WD-DI brings these benefits to Python in a way that is familiar to developers experienced with .NET's DI system, while remaining Pythonic and lightweight.</p>"},{"location":"#example-application","title":"Example Application \ud83d\udca1","text":"<p>For a comprehensive walkthrough of building an application using WD-DI, check out the Tutorial. It demonstrates how to structure an application with layers, manage dependencies, and integrate various WD-DI features.</p>"},{"location":"#best-practices","title":"Best Practices \u2705","text":"<p>When using WD-DI, consider the following best practices:</p> <ol> <li>Constructor Injection: Always prefer constructor injection to clearly state dependencies.</li> <li>Interface Segregation: Register services against interfaces (Abstract Base Classes in Python) for flexibility.</li> <li>Strongly-Typed Configuration: Utilize the Options pattern for managing configurations.</li> <li>Middleware Separation: Keep middleware focused on single responsibilities.</li> </ol>"},{"location":"#license","title":"License \ud83d\udcdc","text":"<p>This project is licensed under the terms of the LICENSE file included in the repository. </p>"},{"location":"getting-started/","title":"Getting Started with WD-DI \ud83d\ude80","text":"<p>This guide will walk you through installing WD-DI and show you a quick example to get you up and running in minutes \u23f1\ufe0f.</p>"},{"location":"getting-started/#installation","title":"Installation \ud83d\udce6","text":"<p>WD-DI is available on PyPI. You can install it using pip:</p> <pre><code>pip install wd-di\n</code></pre> <p>That's it! \ud83c\udf89 WD-DI has no external library dependencies, relying only on Python's standard library.</p>"},{"location":"getting-started/#5-minute-tutorial-your-first-di-application","title":"5-Minute Tutorial: Your First DI Application \ud83d\udee0\ufe0f","text":"<p>Let's build a very simple application to demonstrate the core concepts of WD-DI: registering services, injecting dependencies, and resolving them.</p> <p>Imagine you have a <code>NotifierService</code> that needs an <code>IEmailService</code> to send notifications \ud83d\udce7.</p> <pre><code>from wd.di import ServiceCollection\n\n# 1. Create a service collection \u2699\ufe0f\n# This is the heart of your DI setup, managing all your service registrations.\nservices = ServiceCollection()\n\n# 2. Define your services \ud83d\udcdd\n# It's good practice to define interfaces (Abstract Base Classes in Python)\n# for your services to promote loose coupling.\n\nclass IEmailService:\n    def send(self, message: str):\n        \"\"\"Interface for an email sending service.\"\"\"\n        raise NotImplementedError\n\n# This is a concrete implementation of IEmailService.\n# The @services.singleton(IEmailService) decorator registers this class\n# as the singleton implementation for IEmailService. \ud83c\udf0d\n@services.singleton(IEmailService)\nclass EmailService(IEmailService):\n    def send(self, message: str):\n        print(f\"Sending email: {message}\")\n\n# NotifierService depends on IEmailService.\n# The @services.transient() decorator means a new instance of NotifierService\n# will be created each time it's requested. \u23f3\n@services.transient()\nclass NotifierService:\n    # WD-DI will automatically inject an instance of IEmailService here. \ud83d\udc89\n    def __init__(self, emailer: IEmailService):\n        self._emailer = emailer\n\n    def notify_admin(self, alert: str):\n        self._emailer.send(f\"Admin Alert: {alert}\")\n\n# 3. Build the service provider \ud83c\udfed\n# Once all services are registered, build the provider.\n# The provider is responsible for resolving service instances.\nprovider = services.build_service_provider()\n\n# 4. Resolve and use your services \u2728\n# Request an instance of NotifierService from the provider.\n# WD-DI automatically infers the return type if using type hints.\nnotifier = provider.get_service(NotifierService)\n\n# Now you can use your fully wired service.\nnotifier.notify_admin(\"System critical!\")\n# Expected Output:\n# Sending email: Admin Alert: System critical!\n</code></pre> <p>What happened here? \ud83e\udd14</p> <ol> <li>We created a <code>ServiceCollection</code> to hold our service registrations.</li> <li>We defined an interface <code>IEmailService</code> and its implementation <code>EmailService</code>. <code>EmailService</code> was registered as a singleton, meaning only one instance will be created and shared.</li> <li>We defined <code>NotifierService</code> which depends on <code>IEmailService</code>. It was registered as transient, meaning a new instance is created each time.</li> <li>When <code>NotifierService</code> was resolved, WD-DI saw its constructor required an <code>IEmailService</code>. It then looked up the registered implementation (<code>EmailService</code>), created/retrieved its instance, and passed it to the <code>NotifierService</code> constructor.</li> <li>The <code>notifier</code> instance we got back was fully formed with its <code>EmailService</code> dependency automatically handled. \ud83d\udc4d</li> </ol> <p>This simple example showcases the power of constructor injection and declarative service registration using decorators. Your components don't need to know how to create their dependencies; they just declare what they need, and WD-DI handles the rest.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps \ud83d\uddfa\ufe0f","text":"<p>You're now ready to explore more advanced features of WD-DI! </p> <ul> <li>Dive into Core Concepts to understand service lifetimes, constructor injection in more detail, and configuration.</li> <li>Learn about the Middleware Pipeline for handling cross-cutting concerns.</li> <li>Explore the Tutorial for a step-by-step guide to building a more complex application. </li> </ul>"},{"location":"roadmap/","title":"WD-DI Library Roadmap","text":"<p>This document outlines the planned features and enhancements for the WD-DI library. It is based on the previous internal TODO list and will be updated as the project progresses.</p>"},{"location":"roadmap/#planned-features-and-enhancements","title":"Planned Features and Enhancements","text":""},{"location":"roadmap/#1-dependency-injection-container-enhancements","title":"1. Dependency Injection Container Enhancements","text":"<ul> <li> <p>[x] Scoped Services Resolution &amp; Scope Management Explicit scope creation and disposal management for scoped services have been implemented.</p> </li> <li> <p>[x] Circular Dependency Detection Detection of circular dependencies during resolution (with proper error messages) is now in place.</p> </li> <li> <p>[ ] Open Generic Types Support:   Add the ability to register and resolve open generic types for generic service definitions.</p> </li> <li> <p>[x] Instance Registration: The <code>add_instance</code> API for registering pre-instantiated services has been implemented.</p> </li> <li> <p>[ ] Multiple Implementations / Named Services:   Support multiple registrations for a single service type and allow resolution as collections.</p> </li> <li> <p>[ ] Improved Constructor Injection:   Enhance dependency resolution to handle default parameter values and cases with missing or ambiguous type annotations.</p> </li> <li> <p>[x] Thread Safety Improvements: Review and enhance the container to be thread-safe in multi-threaded environments. (ContextVar for circular dependency stack implemented)</p> </li> </ul>"},{"location":"roadmap/#2-middleware-pipeline-enhancements","title":"2. Middleware Pipeline Enhancements","text":"<ul> <li> <p>[ ] Exception Handling Integration:   Integrate <code>ExceptionHandlerMiddleware</code> into the default pipeline configuration and add tests for graceful error handling.</p> </li> <li> <p>[ ] Middleware Registration &amp; Lifetime Management:   Refine middleware registration to better manage middleware lifetimes and resolve dependencies within appropriate scopes.</p> </li> <li> <p>[ ] Advanced Pipeline Configuration:   Explore features like branching pipelines, conditional middleware execution, or pipeline termination.</p> </li> </ul>"},{"location":"roadmap/#3-optionsconfiguration-enhancements","title":"3. Options/Configuration Enhancements","text":"<ul> <li> <p>[ ] Type Conversion and Validation:   Improve the <code>OptionsBuilder</code> to support robust type conversion and integrate validation logic.</p> </li> <li> <p>[ ] Dynamic Configuration Reloading:   Optionally add support for reloading configuration when underlying sources (e.g., JSON or environment variables) change.</p> </li> </ul>"},{"location":"roadmap/#4-testing-and-documentation","title":"4. Testing and Documentation","text":"<ul> <li> <p>[ ] Expanded Test Coverage:   Add tests for new and pending features (e.g., open generic types, multiple implementations).</p> </li> <li> <p>[ ] Documentation and Code Comments:   Enhance inline documentation, add usage examples, and update the README to guide users.</p> </li> <li> <p>[x] Refactor Global State: The global <code>services</code> instance has been removed. DI container setup now requires explicit <code>ServiceCollection</code> instantiation.</p> </li> </ul>"},{"location":"roadmap/#5-additional-features","title":"5. Additional Features","text":"<ul> <li> <p>[ ] Integration with Python Logging:   Replace default print statements in logging middleware with integration into Python's standard logging module.</p> </li> <li> <p>[ ] Support for Async Service Factories:   Investigate and add support for asynchronous factory methods for services requiring async initialization.</p> </li> <li> <p>[ ] Dependency Injection Extensions:   Create helper functions or decorators for common patterns (e.g., function injection, async injection) to extend the framework's usability.</p> </li> </ul>"},{"location":"roadmap/#future-ideas-and-exploration","title":"Future Ideas and Exploration","text":"<p>This section lists features and concepts that are under consideration for future development or as potential extensions to the library. These are not yet committed items but represent areas of interest.</p> <p>(Note: Code snippets below are conceptual and assume <code>from wd.di import ServiceCollection</code> and <code>sc = create_service_collection()</code> are defined.)</p> <ol> <li> <p>Service Discovery and Assembly Scanning</p> <ul> <li>Auto-registration of services based on decorators/attributes.</li> <li>Scanning assemblies/modules for services marked for registration.</li> <li>Convention-based registration (e.g., all classes ending with 'Service').</li> </ul> </li> <li> <p>Advanced Service Resolution</p> <ul> <li>Named/Keyed Services: <pre><code># sc.add_singleton(IService, ServiceA, name=\"serviceA\")\n# sc.add_singleton(IService, ServiceB, name=\"serviceB\")\n</code></pre></li> <li>Enumerable Resolution (Resolving all implementations of an interface): <pre><code># @sc.singleton()\n# class Processor:\n#     def __init__(self, handlers: list[IHandler]): # Inject all IHandler implementations\n#         self.handlers = handlers\n</code></pre></li> <li>Lazy Resolution: <pre><code># from wd.di import Lazy # Hypothetical Lazy type\n# @sc.singleton()\n# class Service:\n#     def __init__(self, lazy_dep: Lazy[ExpensiveService]):\n#         self._dep = lazy_dep  # ExpensiveService only created when self._dep.value is accessed\n</code></pre></li> </ul> </li> <li> <p>Enhanced Async Support</p> <ul> <li>Async Service Initialization/Factories: (Covered in \"Additional Features\")</li> <li>Async Disposal (<code>aclose</code> or <code>adispose</code>): Support for services that need to perform asynchronous cleanup.     <pre><code># @sc.scoped() # Or other lifetimes\n# class AsyncDisposableResource:\n#     async def setup(self):\n#         # async setup\n#         pass\n#     async def aclose(self): # Or async_dispose\n#         # async cleanup\n#         pass\n# # ServiceProvider scope would need to handle await scope.aclose()\n</code></pre></li> </ul> </li> <li> <p>Enhanced Configuration (beyond current <code>Options</code> pattern)</p> <ul> <li>Environment-Specific Configuration Files: (Already conceptually manageable by how <code>Configuration</code> is built)</li> <li>Binding to Nested Dataclasses: (Already supported by current <code>Options</code> pattern and <code>Configuration</code> section binding)</li> </ul> </li> <li> <p>Service Replacement and Decoration</p> <ul> <li>Replace Existing Registration: <pre><code># sc.replace_singleton(IService, NewImplementation)\n</code></pre></li> <li>Decorate Existing Service: <pre><code># sc.decorate(IService, lambda sp, service_instance: LoggingDecorator(service_instance, sp.get_service(ILogger)))\n</code></pre></li> </ul> </li> <li> <p>Enhanced Validation</p> <ul> <li>Startup Validation: Extended checks during <code>build_service_provider()</code> for common issues.     <pre><code># provider = sc.build_service_provider(validate_on_build=True) # Check for missing dependencies, certain circular refs\n</code></pre></li> <li>Scope Validation: Ensure scoped services aren't inadvertently resolved by singletons in a problematic way.</li> </ul> </li> <li> <p>Service Factory Enhancements</p> <ul> <li>Support for factories that can take runtime parameters beyond just the <code>ServiceProvider</code>.     <pre><code># # For services that need parameters not known at registration time\n# # This is more of an application-level factory pattern that DI can help construct.\n# sc.add_transient_factory(lambda sp, param1: MyServiceWithParams(sp.get_service(IDependency), param1))\n</code></pre></li> </ul> </li> <li> <p>Diagnostics and Debugging Tools</p> <ul> <li>Dependency Graph Visualization: Tools or methods to inspect the resolved dependency tree.</li> <li>Resolution Metrics: Optional tracking of service creation times, instance counts, etc.</li> </ul> </li> <li> <p>Middleware Enhancements (beyond current pipeline)</p> <ul> <li>Ordered Middleware: (Already supported by registration order)</li> <li>Conditional Middleware: (Already possible by implementing logic within <code>invoke</code>)</li> </ul> </li> <li> <p>Scope Features</p> <ul> <li>Named Scopes: (For scenarios requiring multiple distinct types of scopes)</li> <li>Scope Events: Callbacks for scope creation or disposal.</li> </ul> </li> <li> <p>Extended Type Support</p> <ul> <li>Generic Service Support: (Covered in \"Container Enhancements\" - Open Generics)</li> <li>Optional Dependencies: Clear patterns for handling optional dependencies (e.g. <code>dep: IMyService | None = None</code>).</li> </ul> </li> <li> <p>Testing Utilities</p> <ul> <li>Test ServiceProvider/ServiceCollection Helpers: Utilities to simplify mocking or overriding services in test environments.     <pre><code># with sc.override_service(IMyService, MockMyService()):\n#    provider = sc.build_service_provider()\n#    # ... tests ...\n</code></pre></li> </ul> </li> </ol>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>This section delves into more advanced usage patterns and considerations for WD-DI.</p> <ul> <li>Scaling Your Application</li> <li>Anti-Patterns &amp; DI Solutions</li> <li>Circular Dependency Detection </li> </ul>"},{"location":"advanced/anti-patterns/","title":"Common Python Anti-Patterns and DI Solutions","text":"<p>Python's flexibility, while powerful, can lead to common architectural pitfalls if not managed carefully. Using Dependency Injection (DI) as a guiding principle can help avoid these anti-patterns and promote more maintainable, testable, and robust code. WD-DI provides the tools to implement these solutions effectively.</p>"},{"location":"advanced/anti-patterns/#1-global-state-and-singletons-problem","title":"1. Global State and Singletons (Problem)","text":"<p>Anti-Pattern: Relying on globally accessible objects or manually implemented singletons for managing state or services. This makes testing difficult, hides dependencies, and can lead to unpredictable behavior due to shared mutable state.</p> <pre><code># global_config.py (Anti-Pattern)\nclass GlobalConfig:\n    _instance = None\n\n    @classmethod\n    def get_instance(cls):\n        if cls._instance is None:\n            cls._instance = cls()\n        return cls._instance\n\n    def __init__(self):\n        self.api_key = \"GlobalSecret!\"\n        self.debug_mode = True\n\n# Used everywhere in the codebase:\n# from global_config import GlobalConfig\n# config = GlobalConfig.get_instance()\n# if config.debug_mode:\n#     print(f\"API Key: {config.api_key}\")\n</code></pre> <p>DI Solution: Manage such configurations or shared services as singletons within the DI container. Access them via constructor injection where needed.</p> <p><pre><code># DI Solution\nfrom dataclasses import dataclass\nfrom wd.di import create_service_collection\nfrom wd.di.config import Options, IConfiguration, Configuration # Assuming IConfiguration and Configuration are set up\n\nsc = create_service_collection()\n\n@dataclass\nclass AppConfig:\n    api_key: str = \"DefaultKey\"\n    debug_mode: bool = False\n\n# Setup: Register IConfiguration and configure AppConfig\n# This would typically be done once at application startup.\nconfig_values = {\"app\": {\"api_key\": \"LoadedFromConfig\", \"debug_mode\": True}}\nactual_configuration = Configuration(config_values)\nsc.add_singleton_factory(IConfiguration, lambda _: actual_configuration) # Or add_instance\nsc.configure(AppConfig, section=\"app\")\n\n@sc.singleton()\nclass MyConfiguredService:\n    def __init__(self, app_opts: Options[AppConfig]):\n        self.config = app_opts.value # Access the strongly-typed config\n\n    def perform_action(self):\n        if self.config.debug_mode:\n            print(f\"Running in DEBUG. API Key: {self.config.api_key}\")\n        else:\n            print(\"Running in PRODUCTION.\")\n\n# Usage\n# provider = sc.build_service_provider()\n# service = provider.get_service(MyConfiguredService)\n# service.perform_action()\n</code></pre> Benefits: Dependencies are explicit, configuration is testable (mock `Options[AppConfig]), and the DI container manages the singleton lifetime.</p>"},{"location":"advanced/anti-patterns/#2-hidden-dependencies-and-import-time-side-effects-problem","title":"2. Hidden Dependencies and Import-Time Side Effects (Problem)","text":"<p>Anti-Pattern: Modules or classes that create resources (like database connections) or have significant side effects upon import. This makes it hard to manage resource lifetimes and to test components in isolation.</p> <pre><code># database.py (Anti-Pattern)\n# import sqlite3\n\n# Global connection created at import time - hard to manage and test\n# db_connection = sqlite3.connect(\"application.db\") \n\n# class UserRepository:\n#     def get_user_by_id(self, user_id):\n#         cursor = db_connection.cursor()\n#         cursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\n#         return cursor.fetchone()\n</code></pre> <p>DI Solution: Define interfaces for dependencies like database access. Register implementations with appropriate lifetimes (e.g., scoped or transient for connections/sessions, singleton for connection pools/factories). Inject these interfaces into services.</p> <p><pre><code># DI Solution\nfrom abc import ABC, abstractmethod\nimport sqlite3 # For the example implementation\nfrom wd.di import create_service_collection\n\nsc = create_service_collection()\n\nclass IDatabaseConnection(ABC):\n    @abstractmethod\n    def execute(self, query: str, params: tuple) -&gt; list:\n        pass\n    @abstractmethod\n    def close(self):\n        pass # For proper resource management, e.g. in a scoped lifetime\n\n# Implementation (could be scoped in a real app)\n@sc.transient(IDatabaseConnection) # Often scoped or transient\nclass SqliteConnectionWrapper(IDatabaseConnection):\n    def __init__(self, db_path: str = \":memory:\"): # db_path could come from config\n        print(f\"SqliteConnectionWrapper created for {db_path}\")\n        self.connection = sqlite3.connect(db_path)\n\n    def execute(self, query: str, params: tuple) -&gt; list:\n        cursor = self.connection.cursor()\n        cursor.execute(query, params)\n        return cursor.fetchall()\n\n    def close(self):\n        print(\"SqliteConnectionWrapper closing connection.\")\n        self.connection.close()\n\n@sc.singleton()\nclass UserRepository:\n    def __init__(self, db_conn_factory: IDatabaseConnection): # Injects a transient connection\n        self.db_conn = db_conn_factory # Or a factory that provides connections\n\n    def get_user_by_id(self, user_id: int) -&gt; list:\n        # In a real app, connection lifecycle (open/close) would be managed carefully,\n        # often by using the connection as a context manager if it supports it,\n        # or by having the DI scope manage its disposal (e.g. via close method).\n        data = self.db_conn.execute(\"SELECT ? AS id, ? AS name\", (user_id, \"Test\"))\n        # self.db_conn.close() # If transient, scope would call close if disposable\n        return data\n\n# Usage\n# provider = sc.build_service_provider()\n# with provider.create_scope() as scope:\n#     user_repo = scope.get_service(UserRepository)\n#     user = user_repo.get_user_by_id(123)\n#     print(f\"User from repo: {user}\")\n# The SqliteConnectionWrapper's close() method would be called on scope disposal.\n</code></pre> Benefits: Resource creation is managed by DI, promoting better lifetime control and testability (mock <code>IDatabaseConnection</code>).</p>"},{"location":"advanced/anti-patterns/#3-module-level-functions-creating-tight-coupling-problem","title":"3. Module-Level Functions Creating Tight Coupling (Problem)","text":"<p>Anti-Pattern: Using module-level functions that directly call other module-level functions across different parts of your application. This can lead to a tangled web of dependencies that are hard to trace and test, and can easily result in circular import issues if not careful.</p> <pre><code># user_processing.py (Anti-Pattern)\n# import order_processing # Potential circular import risk\n# \n# def get_user_summary(user_id):\n#     user_details = {\"id\": user_id, \"name\": \"Some User\"} # fetch_user_from_db(user_id)\n#     user_orders = order_processing.get_orders_for_user(user_id)\n#     return {**user_details, \"orders\": user_orders}\n\n# order_processing.py (Anti-Pattern)\n# import user_processing # Potential circular import risk\n# \n# def get_orders_for_user(user_id):\n#     # May need user details for some logic, leading to circular call\n#     # if user_processing.is_user_premium(user_id):\n#     #     return [{\"id\": \"premium_order_123\"}]\n#     return [{\"id\": \"order_abc\", \"items\": 2}, {\"id\": \"order_xyz\", \"items\": 1}]\n</code></pre> <p>DI Solution: Encapsulate logic within classes (services) and define clear interfaces. Inject dependencies via constructors. This breaks circular dependencies at the module import level and makes them manageable (or highlights problematic circular logic) at the service resolution level.</p> <p><pre><code># DI Solution\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\nfrom wd.di import create_service_collection\n\nsc = create_service_collection()\n\nclass IOrderService(ABC):\n    @abstractmethod\n    def get_orders_for_user(self, user_id: str) -&gt; List[Dict[str, Any]]:\n        pass\n\nclass IUserService(ABC):\n    @abstractmethod\n    def get_user_summary(self, user_id: str) -&gt; Dict[str, Any]:\n        pass\n\n@sc.singleton(IOrderService)\nclass OrderService(IOrderService):\n    # If OrderService needed IUserService, it would be injected here.\n    # For this example, assume it does not to keep it simple.\n    def get_orders_for_user(self, user_id: str) -&gt; List[Dict[str, Any]]:\n        print(f\"OrderService: Getting orders for {user_id}\")\n        return [{f\"order_id\": f\"{user_id}_order1\"}]\n\n@sc.singleton(IUserService)\nclass UserService(IUserService):\n    def __init__(self, order_service: IOrderService):\n        self._order_service = order_service\n\n    def get_user_summary(self, user_id: str) -&gt; Dict[str, Any]:\n        print(f\"UserService: Getting summary for {user_id}\")\n        user_details = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n        user_orders = self._order_service.get_orders_for_user(user_id)\n        return {**user_details, \"orders\": user_orders}\n\n# Usage\n# provider = sc.build_service_provider()\n# user_service_instance = provider.get_service(IUserService)\n# summary = user_service_instance.get_user_summary(\"USR456\")\n# print(f\"User Summary: {summary}\")\n</code></pre> Benefits: Dependencies are explicit through constructor injection. Circular dependencies become easier to identify and manage at the class/service level. Testing is simplified by mocking injected interfaces.</p>"},{"location":"advanced/anti-patterns/#4-monolithic-classes-with-mixed-responsibilities-problem","title":"4. Monolithic Classes with Mixed Responsibilities (Problem)","text":"<p>Anti-Pattern: Large classes that handle too many concerns (e.g., data access, business logic, notifications, logging all in one class). This violates the Single Responsibility Principle, making the class hard to understand, modify, and test.</p> <pre><code># class GodUserManager(AntiPattern):\n#     def __init__(self):\n#         # self.db = connect_db()\n#         # self.mailer = setup_mailer()\n#         # self.logger = setup_logger()\n#         pass\n# \n#     def create_user_and_notify(self, email, password):\n#         # self.logger.info(f\"Attempting to create {email}\")\n#         # user = self.db.save_user(email, password)\n#         # self.mailer.send_welcome_email(email)\n#         # self.logger.info(f\"User {email} created and notified.\")\n#         pass\n</code></pre> <p>DI Solution: Break down monolithic classes into smaller, focused services, each with a single responsibility. Use DI to inject these fine-grained services where needed.</p> <p><pre><code># DI Solution\nfrom abc import ABC, abstractmethod\nfrom wd.di import create_service_collection\n\nsc = create_service_collection()\n\n# Define Interfaces (examples)\nclass IUserRepository(ABC):\n    @abstractmethod\n    def save_user(self, email: str, password: str) -&gt; dict:\n        pass\n\nclass IEmailService(ABC):\n    @abstractmethod\n    def send_welcome_email(self, email: str):\n        pass\n\nclass ILogger(ABC):\n    @abstractmethod\n    def info(self, message: str):\n        pass\n\n# Concrete Implementations (simplified examples, register with @sc decorators)\n@sc.singleton(ILogger)\nclass ConsoleLogger(ILogger):\n    def info(self, message: str):\n        print(f\"[INFO] {message}\")\n\n@sc.singleton(IEmailService)\nclass EmailService(IEmailService):\n    def __init__(self, logger: ILogger):\n        self.logger = logger\n    def send_welcome_email(self, email: str):\n        self.logger.info(f\"EmailService: Sending welcome email to {email}\")\n\n@sc.singleton(IUserRepository)\nclass UserRepository(IUserRepository):\n    def __init__(self, logger: ILogger):\n        self.logger = logger\n    def save_user(self, email: str, password: str) -&gt; dict:\n        self.logger.info(f\"UserRepository: Saving user {email}\")\n        return {\"id\": \"user_123\", \"email\": email}\n\n# Main orchestrating service\n@sc.singleton()\nclass UserCreationService:\n    def __init__(self, repo: IUserRepository, mailer: IEmailService, logger: ILogger):\n        self._repo = repo\n        self._mailer = mailer\n        self._logger = logger\n\n    def create_user_and_notify(self, email: str, password: str):\n        self._logger.info(f\"UserCreationService: Attempting to create {email}\")\n        user = self._repo.save_user(email, password)\n        self._mailer.send_welcome_email(email)\n        self._logger.info(f\"UserCreationService: User {email} created and notified.\")\n        return user\n\n# Usage\n# provider = sc.build_service_provider()\n# user_creator = provider.get_service(UserCreationService)\n# new_user = user_creator.create_user_and_notify(\"test@example.com\", \"password123\")\n# print(f\"New user created: {new_user}\")\n</code></pre> Benefits: Each service has a clear responsibility, improving code clarity, reusability, and testability. Changes to one aspect (e.g., email sending logic) are isolated to one service.</p>"},{"location":"advanced/anti-patterns/#5-static-methods-and-utility-classes-problem","title":"5. Static Methods and Utility Classes (Problem)","text":"<p>Anti-Pattern: Overuse of static methods or utility classes with many static functions for common operations (e.g., validation, calculation). While sometimes convenient, they can become dependency sinks, are hard to mock for testing, and don't fit well into an object-oriented design that relies on polymorphism or swappable implementations.</p> <pre><code># class PaymentUtils(AntiPattern):\n#     @staticmethod\n#     def calculate_tax(amount):\n#         return amount * 0.20 # Fixed tax rate\n# \n#     @staticmethod\n#     def is_card_valid(card_number):\n#         return len(card_number) == 16\n# \n# class OldOrderProcessor:\n#     def process_order(self, amount, card):\n#         if PaymentUtils.is_card_valid(card):\n#             total_with_tax = amount + PaymentUtils.calculate_tax(amount)\n#             # ... process payment ...\n#             return total_with_tax\n#         raise ValueError(\"Invalid card\")\n</code></pre> <p>DI Solution: Encapsulate such logic into services (even small, focused ones) with well-defined interfaces. These services can then be injected and easily mocked or replaced.</p> <p><pre><code># DI Solution\nfrom abc import ABC, abstractmethod\nfrom wd.di import create_service_collection\n\nsc = create_service_collection()\n\nclass ITaxCalculator(ABC):\n    @abstractmethod\n    def calculate_tax(self, amount: float) -&gt; float:\n        pass\n\nclass ICardValidator(ABC):\n    @abstractmethod\n    def is_card_valid(self, card_number: str) -&gt; bool:\n        pass\n\n@sc.singleton(ITaxCalculator)\nclass DefaultTaxCalculator(ITaxCalculator):\n    def calculate_tax(self, amount: float) -&gt; float:\n        return amount * 0.20 # Example: 20% tax\n\n@sc.singleton(ICardValidator)\nclass StandardCardValidator(ICardValidator):\n    def is_card_valid(self, card_number: str) -&gt; bool:\n        return len(card_number) == 16 # Simple validation\n\n@sc.singleton()\nclass NewOrderProcessor:\n    def __init__(self, tax_calc: ITaxCalculator, card_validator: ICardValidator):\n        self._tax_calc = tax_calc\n        self._card_validator = card_validator\n\n    def process_order(self, amount: float, card_number: str) -&gt; float:\n        if not self._card_validator.is_card_valid(card_number):\n            raise ValueError(\"Invalid card number provided.\")\n\n        tax_amount = self._tax_calc.calculate_tax(amount)\n        total_with_tax = amount + tax_amount\n        print(f\"Processing payment for: {total_with_tax} (Amount: {amount}, Tax: {tax_amount})\")\n        # ... actual payment processing logic ...\n        return total_with_tax\n\n# Usage\n# provider = sc.build_service_provider()\n# order_processor = provider.get_service(NewOrderProcessor)\n# try:\n#     total = order_processor.process_order(100.00, \"1234567890123456\")\n#     print(f\"Order processed successfully. Total: {total}\")\n#     order_processor.process_order(50.00, \"invalidcard\")\n# except ValueError as e:\n#     print(f\"Error processing order: {e}\")\n</code></pre> Benefits: Utility logic becomes part of the DI-managed object graph. Implementations can be swapped (e.g., different tax calculators for different regions). Services are easily testable by mocking their dependencies (e.g., mock <code>ITaxCalculator</code>).</p> <p>By recognizing these anti-patterns and applying DI principles, you can build more flexible, robust, and maintainable Python applications with WD-DI. </p>"},{"location":"advanced/circular-deps/","title":"Circular Dependency Detection","text":"<p>Circular dependencies occur when two or more services depend on each other directly or indirectly, creating a loop that cannot be resolved. For example, Service A depends on Service B, and Service B depends on Service A. Such a situation can lead to infinite recursion during instantiation if not detected.</p> <p>WD-DI is designed to detect and report these circular dependencies at runtime, preventing your application from crashing due to stack overflows or unresolvable states.</p>"},{"location":"advanced/circular-deps/#how-wd-di-detects-circular-dependencies","title":"How WD-DI Detects Circular Dependencies","text":"<p>WD-DI uses a <code>ContextVar</code> (a context-local variable, ensuring thread/task safety for asynchronous applications) to keep track of the set of services that are currently in the process of being resolved for a given request chain.</p> <p>When you request a service from the <code>ServiceProvider</code> (or a <code>Scope</code>): 1.  Before attempting to create an instance of the requested service, WD-DI adds the service's unique key (usually its type or interface) to this <code>ContextVar</code> set. 2.  If the service has dependencies, WD-DI recursively attempts to resolve them. 3.  If, during this recursive resolution, WD-DI encounters a request for a service key that is already present in the <code>ContextVar</code> set for the current resolution path, it means a circular dependency has been detected. 4.  Once the service (and its dependencies) are successfully resolved, its key is removed from the <code>ContextVar</code> set for that path, allowing other independent resolutions of the same service type if needed (e.g., for transient services requested multiple times by different branches of a dependency graph).</p> <p>This mechanism ensures that a circular loop is caught before it can cause an infinite instantiation loop.</p>"},{"location":"advanced/circular-deps/#circulardependencyerror","title":"<code>CircularDependencyError</code>","text":"<p>When a circular dependency is detected, WD-DI raises a <code>wd.di.errors.CircularDependencyError</code>. This error typically includes a message indicating the service type that caused the cycle and often the chain of dependencies involved.</p>"},{"location":"advanced/circular-deps/#example-of-a-circular-dependency","title":"Example of a Circular Dependency","text":"<p>Consider two services, <code>ServiceA</code> and <code>ServiceB</code>, that depend on each other:</p> <pre><code>from wd.di import create_service_collection\nfrom wd.di.errors import CircularDependencyError\n\nsc = create_service_collection()\n\n# Forward declaration for type hints if classes are in the same scope\nclass ServiceB: ...\n\n@sc.singleton()\nclass ServiceA:\n    def __init__(self, b: ServiceB): # ServiceA depends on ServiceB\n        self.b = b\n        print(\"ServiceA created\")\n\n@sc.singleton()\nclass ServiceB:\n    def __init__(self, a: ServiceA): # ServiceB depends on ServiceA\n        self.a = a\n        print(\"ServiceB created\")\n\n# --- Attempt to resolve ---\nprovider = sc.build_service_provider()\n\ntry:\n    # Requesting either ServiceA or ServiceB will trigger the error\n    service_a = provider.get_service(ServiceA)\nexcept CircularDependencyError as e:\n    print(f\"Caught expected error: {e}\")\n    # Example error message might be:\n    # \"Circular dependency detected while resolving type &lt;class '__main__.ServiceA'&gt;. Resolution path: {&lt;class '__main__.ServiceA'&gt;, &lt;class '__main__.ServiceB'&gt;}\"\n\n# Expected Output (simplified, actual message might vary slightly):\n# Caught expected error: Circular dependency detected for service &lt;class '__main__.ServiceA'&gt;. Current resolution path: {&lt;ServiceKey for ServiceA&gt;, &lt;ServiceKey for ServiceB&gt;}\n</code></pre> <p>In this scenario: 1.  Resolving <code>ServiceA</code> requires <code>ServiceB</code>. <code>ServiceA</code> is added to the resolution stack. 2.  Resolving <code>ServiceB</code> (for <code>ServiceA</code>) requires <code>ServiceA</code>. <code>ServiceB</code> is added to the resolution stack. 3.  Attempting to resolve <code>ServiceA</code> (for <code>ServiceB</code>) finds <code>ServiceA</code> already in the resolution stack, triggering <code>CircularDependencyError</code>.</p>"},{"location":"advanced/circular-deps/#resolving-circular-dependencies","title":"Resolving Circular Dependencies","text":"<p>If you encounter a <code>CircularDependencyError</code>, it's a signal that your application's design has a problematic dependency loop. WD-DI does not provide mechanisms to \"break\" the cycle automatically (e.g., with lazy proxies for one of the dependencies) because circular dependencies often indicate a deeper architectural issue.</p> <p>The recommended ways to resolve circular dependencies are:</p> <ol> <li>Refactor your services:<ul> <li>Interface Segregation: Introduce an interface that one of the services can depend on, and have the other service implement it. This can sometimes break the direct cycle if the interface is more focused.</li> <li>Mediator Pattern: Introduce a third service (a mediator) that both services depend on. The original services then communicate through the mediator rather than directly.</li> <li>Re-evaluate Responsibilities: Often, a circular dependency suggests that one or both services are doing too much or that responsibilities are not clearly separated. Splitting services into smaller, more focused units can help.</li> </ul> </li> <li>Property/Method Injection (Use with Caution):<ul> <li>While constructor injection is preferred, you could, in some rare cases, break a cycle by having one service set a dependency on another via a property or method after both are constructed. This is generally not recommended as it makes dependencies less explicit and can lead to objects being in an incompletely initialized state. WD-DI focuses on constructor injection.</li> </ul> </li> <li>Eventual Consistency/Callbacks:<ul> <li>Instead of a direct synchronous dependency, one service might raise an event that the other service subscribes to, decoupling them.</li> </ul> </li> </ol> <p>The best approach is usually to refactor the dependencies to eliminate the circularity, leading to a cleaner and more understandable architecture. </p>"},{"location":"advanced/decorators/","title":"Service Decorators","text":"<p>The dependency injection container supports a powerful decorator pattern that allows you to wrap, intercept, or modify service instances after they are created but before they are returned to the caller or cached by their lifetime manager. This is an implementation of the Decorator design pattern applied to services managed by the DI container.</p> <p>Decorators are registered against a specific service type and are applied in the reverse order of their registration (the last decorator registered is the outermost).</p>"},{"location":"advanced/decorators/#use-cases","title":"Use Cases","text":"<p>Service decorators are useful for a variety of cross-cutting concerns, such as:</p> <ul> <li>Caching: Wrap a service with a caching layer.</li> <li>Logging/Auditing: Log method calls to a service or audit actions.</li> <li>Transaction Management: Start and commit/rollback transactions around service method calls.</li> <li>Retries/Circuit Breakers: Add resilience to service operations.</li> <li>Data Validation/Transformation: Validate input or transform output of service methods.</li> <li>Feature Toggling: Conditionally alter behavior by applying different decorators.</li> </ul>"},{"location":"advanced/decorators/#registering-decorators","title":"Registering Decorators","text":"<p>You register decorators using the <code>decorate</code> method on the <code>ServiceCollection</code>:</p> <pre><code>from wd.di import ServiceCollection, ServiceProvider\n\n# 1. Define your service interface and implementation\nclass IDataService:\n    def get_data(self, item_id: str) -&gt; str:\n        raise NotImplementedError\n\nclass RealDataService(IDataService):\n    def get_data(self, item_id: str) -&gt; str:\n        print(f\"RealDataService: Fetching data for {item_id}\")\n        return f\"Data for {item_id}\"\n\n# 2. Define your decorator(s)\nclass LoggingDecorator(IDataService):\n    def __init__(self, inner: IDataService, provider: ServiceProvider):\n        self._inner = inner\n        self._provider = provider # Example: if decorator needs other services\n        print(\"LoggingDecorator: Initialized\")\n\n    def get_data(self, item_id: str) -&gt; str:\n        print(f\"LoggingDecorator: Before calling get_data for {item_id}\")\n        result = self._inner.get_data(item_id)\n        print(f\"LoggingDecorator: After calling get_data for {item_id}, result: {result}\")\n        return result\n\n# 3. Define a decorator factory\n# A decorator factory is a callable that takes two arguments:\n# - The current ServiceProvider instance.\n# - The \"inner\" service instance that is being decorated.\n# It must return the decorated instance.\ndef logging_decorator_factory(provider: ServiceProvider, inner_service: IDataService) -&gt; IDataService:\n    return LoggingDecorator(inner_service, provider)\n\n# 4. Configure services\nservices = ServiceCollection()\nservices.add_transient(IDataService, RealDataService)\n\n# 5. Apply the decorator\nservices.decorate(IDataService, logging_decorator_factory)\n\n# 6. Build and use\nprovider = services.build_service_provider()\ndata_service = provider.get_service(IDataService)\ndata_service.get_data(\"item123\")\n\n# Output would be:\n# LoggingDecorator: Initialized\n# LoggingDecorator: Before calling get_data for item123\n# RealDataService: Fetching data for item123\n# LoggingDecorator: After calling get_data for item123, result: Data for item123\n</code></pre>"},{"location":"advanced/decorators/#decorator-factories","title":"Decorator Factories","text":"<p>A decorator factory is a callable with the signature:</p> <pre><code>Callable[[ServiceProvider, InnerServiceType], OuterServiceType]\n</code></pre> <ul> <li><code>ServiceProvider</code>: The current service provider, which can be used by the decorator to resolve other dependencies if needed.</li> <li><code>InnerServiceType</code>: The instance of the service being wrapped.</li> <li><code>OuterServiceType</code>: The (potentially) wrapped instance that will be returned. Often, this is the same type as <code>InnerServiceType</code>, but it can be different if the decorator changes the interface (though this should be done with care).</li> </ul>"},{"location":"advanced/decorators/#order-of-application","title":"Order of Application","text":"<p>If multiple decorators are registered for the same service type, they are applied sequentially. The <code>ServiceDescriptor</code> stores them in a list. When an instance is created: 1.  The base instance (from <code>implementation_type</code> or <code>factory</code>) is created. 2.  The decorators are applied in reverse order of registration. This means the decorator registered last becomes the outermost wrapper, and the decorator registered first becomes the innermost wrapper (closest to the original service instance).</p> <pre><code>services.decorate(IMyService, inner_decorator_factory) # Applied first (becomes inner)\nservices.decorate(IMyService, outer_decorator_factory) # Applied second (becomes outer)\n\n# Execution flow: outer_decorator -&gt; inner_decorator -&gt; actual_service\n</code></pre>"},{"location":"advanced/decorators/#advanced-decorators-with-parameters","title":"Advanced: Decorators with Parameters","text":"<p>Sometimes, your decorator itself might need configuration. You can achieve this by creating a decorator factory function that takes parameters and returns the actual decorator factory callable:</p> <pre><code>class RetryingDataServiceDecorator(IDataService):\n    def __init__(self, inner: IDataService, max_retries: int):\n        self._inner = inner\n        self._max_retries = max_retries\n\n    def get_data(self, item_id: str) -&gt; str:\n        attempts = 0\n        while True:\n            try:\n                return self._inner.get_data(item_id)\n            except Exception as e:\n                attempts += 1\n                if attempts &gt;= self._max_retries:\n                    print(f\"RetryingDecorator: Max retries ({self._max_retries}) reached. Failing.\")\n                    raise\n                print(f\"RetryingDecorator: Attempt {attempts} failed. Retrying...\")\n                # In a real scenario, you might add a delay here\n\n# Factory that creates the decorator factory\ndef create_retrying_decorator_factory(max_retries: int):\n    def actual_decorator_factory(provider: ServiceProvider, inner: IDataService) -&gt; IDataService:\n        return RetryingDataServiceDecorator(inner, max_retries)\n    return actual_decorator_factory\n\n# Usage:\nservices.add_transient(IDataService, RealDataService)\nretry_factory_with_config = create_retrying_decorator_factory(max_retries=3)\nservices.decorate(IDataService, retry_factory_with_config)\n\nprovider = services.build_service_provider()\nservice = provider.get_service(IDataService)\n# service.get_data(\"test\") will now have retry logic\n</code></pre>"},{"location":"advanced/decorators/#circular-decorator-detection","title":"Circular Decorator Detection","text":"<p>The container includes a mechanism to detect circular decorator applications at runtime. If a decorator, during its application to a service, causes itself to be re-applied to the same service instance resolution, a <code>CircularDecoratorError</code> will be raised. This helps prevent infinite loops during service construction.</p> <p>For example, if <code>DecoratorA</code> for <code>IServiceX</code> internally tries to resolve <code>IServiceX</code> again in a way that re-triggers the application of <code>DecoratorA</code> to the same <code>IServiceX</code> instance being formed, a cycle is detected. </p>"},{"location":"advanced/scaling/","title":"Scaling Your Application with WD-DI: Layered Architecture","text":"<p>Structuring your application into layers (e.g., Domain, Data Access, Application/Service, Presentation, Infrastructure) is a common and effective pattern for managing complexity and enhancing scalability and maintainability. WD-DI helps manage dependencies between these layers cleanly.</p> <p>Principle: Organize your code into distinct layers, each with a specific responsibility. Use Dependency Injection to provide dependencies to classes within a layer or from a lower layer to an upper layer. Avoid direct dependencies from lower layers to upper layers.</p> <p>Example: Layered Application</p> <p>Let's assume we have a <code>ServiceCollection</code> instance, <code>sc</code>, created via <code>sc = create_service_collection()</code>.</p> <p>Domain Layer: Defines core business entities and interfaces.</p> <pre><code>from abc import ABC, abstractmethod\n# sc = create_service_collection() # Assume sc is available globally for these snippets for brevity\n\nclass IOrderService(ABC):\n    @abstractmethod\n    def process_order(self, order_id: str):\n        pass\n\n# OrderService would typically be in an Application/Service Layer\n# For this example, let's imagine it's simple enough or defined elsewhere.\n</code></pre> <p>Data Access Layer (Repository Pattern): Handles data persistence.</p> <pre><code># from abc import ABC, abstractmethod # Already imported\n# class IOrderService(ABC): ... # Defined above\n\nclass IOrderRepository(ABC):\n    @abstractmethod\n    def get_order(self, order_id: str) -&gt; dict:\n        pass\n    @abstractmethod\n    def save_order(self, order_data: dict):\n        pass # Added save_order for completeness\n\n# Example implementation for IOrderRepository\n# @sc.singleton(IOrderRepository) # Decorator would be on the concrete class\n# class OrderRepository(IOrderRepository):\n#     def get_order(self, order_id: str) -&gt; dict:\n#         print(f\"DAL: Getting order {order_id} from database.\")\n#         return {\"id\": order_id, \"item\": \"Book from DB\", \"status\": \"Pending\"}\n#     def save_order(self, order_data: dict):\n#         print(f\"DAL: Saving order {order_data.get('id')} to database.\")\n</code></pre> <p>Application/Service Layer: Contains business logic and orchestrates tasks, using services from the Domain and Data Access layers.</p> <pre><code># from abc import ABC, abstractmethod # Already imported\n# class IOrderService(ABC): ... # Defined above\n# class IOrderRepository(ABC): ... # Defined above\n\n# @sc.singleton(IOrderService) # Decorator for OrderService implementation\n# class OrderService(IOrderService):\n#     def __init__(self, order_repo: IOrderRepository):\n#         self.order_repo = order_repo\n#\n#     def process_order(self, order_id: str):\n#         print(f\"APP: Processing order {order_id}\")\n#         order = self.order_repo.get_order(order_id)\n#         # ... some business logic ...\n#         order[\"status\"] = \"Processed\"\n#         self.order_repo.save_order(order)\n#         print(f\"APP: Order {order_id} processed and saved.\")\n</code></pre> <p>Presentation Layer (e.g., Controller): Handles user interaction or API requests and uses services from the Application Layer.</p> <pre><code># class IOrderService(ABC): ... # Defined above\n\n# @sc.transient() # Controllers are often transient\n# class OrderController:\n#     def __init__(self, order_service: IOrderService):\n#         self.order_service = order_service\n#\n#     def handle_web_request_for_order(self, order_id_from_request: str):\n#         print(f\"PRES: Received request for order {order_id_from_request}\")\n#         self.order_service.process_order(order_id_from_request)\n#         print(f\"PRES: Order {order_id_from_request} processing initiated.\")\n</code></pre> <p>Infrastructure Layer: Contains cross-cutting concerns like logging, external service clients, etc. These can be injected into any layer where needed.</p> <pre><code># Example: A simple logger (could be more complex and registered via its own interface)\n# @sc.singleton() # Registering a concrete logger as a singleton\n# class ConsoleLogger:\n#     def log(self, message: str):\n#         print(f\"[LOG] {message}\")\n\n# An OrderService might then take ILogger (if defined) or ConsoleLogger:\n# class OrderService(IOrderService):\n#     def __init__(self, order_repo: IOrderRepository, logger: ConsoleLogger):\n#         self.order_repo = order_repo\n#         self.logger = logger\n#         # ... rest of the implementation ...\n</code></pre> <p>Assembling and Running the Application (Illustrative)</p> <p>To make the above runnable, you'd need concrete classes and actual registration. Here's a more complete, self-contained example showing how these decorated classes would be registered and used:</p> <pre><code>from abc import ABC, abstractmethod\nfrom wd.di import create_service_collection\n\nsc = create_service_collection()\n\n# --- Interfaces (Domain Layer) ---\nclass IOrderRepository(ABC):\n    @abstractmethod\n    def get_order(self, order_id: str) -&gt; dict:\n        pass\n    @abstractmethod\n    def save_order(self, order_data: dict):\n        pass\n\nclass IOrderService(ABC):\n    @abstractmethod\n    def process_order(self, order_id: str):\n        pass\n\nclass ILogger(ABC):\n    @abstractmethod\n    def log(self, message: str):\n        pass_a\n\n# --- Implementations (Various Layers) ---\n@sc.singleton(ILogger)\nclass ConsoleLogger(ILogger):\n    def log(self, message: str):\n        print(f\"[LOG] {message}\")\n\n@sc.singleton(IOrderRepository)\nclass OrderRepository(IOrderRepository):\n    def __init__(self, logger: ILogger):\n        self.logger = logger\n\n    def get_order(self, order_id: str) -&gt; dict:\n        self.logger.log(f\"DAL: Getting order {order_id} from database.\")\n        return {\"id\": order_id, \"item\": \"Book from DB\", \"status\": \"Pending\"}\n\n    def save_order(self, order_data: dict):\n        self.logger.log(f\"DAL: Saving order {order_data.get('id')} to database.\")\n\n@sc.singleton(IOrderService)\nclass OrderService(IOrderService):\n    def __init__(self, order_repo: IOrderRepository, logger: ILogger):\n        self.order_repo = order_repo\n        self.logger = logger\n\n    def process_order(self, order_id: str):\n        self.logger.log(f\"APP: Processing order {order_id}\")\n        order = self.order_repo.get_order(order_id)\n        # ... some business logic ...\n        order[\"status\"] = \"Processed\"\n        self.order_repo.save_order(order)\n        self.logger.log(f\"APP: Order {order_id} processed and saved.\")\n\n@sc.transient() # Controllers are often transient or scoped\nclass OrderController:\n    def __init__(self, order_service: IOrderService, logger: ILogger):\n        self.order_service = order_service\n        self.logger = logger\n\n    def handle_web_request_for_order(self, order_id_from_request: str):\n        self.logger.log(f\"PRES: Received request for order {order_id_from_request}\")\n        self.order_service.process_order(order_id_from_request)\n        self.logger.log(f\"PRES: Order {order_id_from_request} processing initiated.\")\n\n# --- Build and Run ---\nprovider = sc.build_service_provider()\n\ncontroller = provider.get_service(OrderController)\ncontroller.handle_web_request_for_order(\"order123\")\n\n# Expected Output:\n# [LOG] PRES: Received request for order order123\n# [LOG] APP: Processing order order123\n# [LOG] DAL: Getting order order123 from database.\n# [LOG] DAL: Saving order order123 to database.\n# [LOG] APP: Order order123 processed and saved.\n# [LOG] PRES: Order order123 processing initiated.\n</code></pre> <p>When to use Layered Architecture: Build a layered architecture using WD-DI to cleanly separate business logic, data access, presentation, and infrastructure concerns. This enhances maintainability, testability (as layers can be tested in isolation by mocking adjacent layers), and scalability by allowing individual layers to be developed, deployed, and scaled independently (to some extent).</p> <p>This approach helps in: *   Separation of Concerns: Each layer has a well-defined responsibility. *   Maintainability: Changes in one layer are less likely to impact other layers. *   Testability: Layers can be tested independently by mocking dependencies from other layers. *   Scalability: Different layers can potentially be scaled independently if the architecture allows (e.g., multiple instances of the presentation layer).</p> <p>WD-DI facilitates this by making the dependencies between these layers explicit and manageable.</p>"},{"location":"advanced/scaling/#start-simple-then-expand","title":"Start Simple, Then Expand","text":"<p>Principle: Begin with a minimal DI setup. As your project grows, you can introduce more sophisticated patterns like layered architectures, detailed interface-driven design, middleware pipelines, and dynamic configuration incrementally.</p> <p>Example:</p> <pre><code>from wd.di import create_service_collection\n# Assume some services are defined, e.g.:\n# class DatabaseService: ...\n# class UserService: ...\n# class LoggingMiddleware: # (from wd.di.middleware or custom)\n#     async def invoke(self, context, next_call): ...\n\nsc = create_service_collection()\n\n# Initial phase: Register core services (decorators make this concise)\n# @sc.singleton()\n# class DatabaseService:\n#     def connect(self):\n#         print(\"DB Connected\")\n# @sc.singleton()\n# class UserService:\n#     def __init__(self, db: DatabaseService):\n#         self.db = db\n#     def get_user(self):\n#         self.db.connect()\n#         print(\"User fetched\")\n\n# provider = sc.build_service_provider()\n# user_service = provider.get_service(UserService)\n# user_service.get_user()\n\n# Later, as the project evolves, integrate additional layers and middleware:\n# (Assuming LoggingMiddleware is defined and UserService, DatabaseService are decorated)\n\n# app_builder = sc.create_application_builder()\n# app_builder.configure_middleware(lambda builder: (\n#     builder.use_middleware(LoggingMiddleware) # Middleware needs to be DI-aware or resolvable\n# ))\n# # provider_with_middleware = app_builder.build()\n# # Now, resolving services from provider_with_middleware will allow middleware pipeline execution (if pipeline is invoked)\n</code></pre> <p>When to use: Adopt an incremental approach to DI.  1. Start by registering your main services, perhaps using decorators for conciseness. 2. As complexity grows, introduce interfaces to decouple components further. 3. For cross-cutting concerns (logging, auth, error handling), implement a middleware pipeline. 4. Utilize the options pattern for robust configuration management as your application needs to support different environments or settings.</p> <p>This evolutionary approach allows your architecture to adapt to the project's needs without over-engineering from the start. </p>"},{"location":"advanced-examples/","title":"Advanced Examples","text":"<p>This section provides more complex, real-world inspired examples demonstrating various features and patterns with <code>wd-di</code>.</p> <ul> <li>Multi-Tenant Ingestion Service: Showcases dynamic dependency resolution based on runtime context (e.g., tenant ID), scoped services, factory providers, and <code>ContextVar</code> integration for context propagation. </li> </ul>"},{"location":"advanced-examples/multi-tenant-ingestion/","title":"Advanced Example: Multi-Tenant Ingestion Service","text":"<p>This example demonstrates a more complex use case for <code>wd-di</code>, showcasing how to build a multi-tenant file ingestion service where each tenant uses a different cloud storage backend. It highlights features like scoped services, factory-based dependency resolution, <code>ContextVar</code> for managing tenant context, and configuration-driven behavior.</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#the-scenario-multi-tenant-uploads","title":"\ud83c\udf29\ufe0f The Scenario: Multi-Tenant Uploads","text":"<p>Imagine an ingestion service where each customer (tenant) insists on using their own cloud storage provider:</p> <ul> <li>ACME Ltd. \u2192 AWS S3</li> <li>Contoso \u2192 Azure Blob Storage</li> <li>Globex \u2192 Google Cloud Storage</li> </ul> <p>At runtime, your application might receive an HTTP header like <code>X-Tenant-Id: ACME</code> and must dynamically choose and use the correct storage backend for that tenant.</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#why-use-dependency-injection-for-this","title":"Why Use Dependency Injection for This?","text":"<p>Using <code>wd-di</code> for this scenario offers significant advantages over manual, conditional logic (e.g., large <code>if/elif</code> blocks):</p> <ul> <li>Pluggable Backends: Adding a new tenant or storage provider (e.g., \"DigitalOcean Spaces\") becomes a matter of adding a new storage implementation class and updating a configuration mapping. No changes are needed in the core ingestion logic.</li> <li>Constructor Injection: Storage backend implementations can themselves depend on other services (like a clock, logger, or authentication service). The DI container automatically resolves and injects these dependencies when creating a backend instance.</li> <li>Enhanced Testability: During testing, you can easily swap out real cloud storage backends for a mock implementation (e.g., one that writes to the local file system or an in-memory store). This is done by simply registering the mock implementation in the <code>ServiceCollection</code> during test setup.</li> </ul>"},{"location":"advanced-examples/multi-tenant-ingestion/#key-di-concepts-demonstrated","title":"Key DI Concepts Demonstrated","text":"<p>This example utilizes several important <code>wd-di</code> features:</p> <ol> <li><code>ServiceCollection</code>: Used as the central registry for all service definitions (interfaces and their concrete implementations or factories).</li> <li><code>ContextVar</code> for Tenant ID: A <code>contextvars.ContextVar</code> (<code>_current_tenant</code>) is used to implicitly carry the current tenant ID through asynchronous call chains without needing to pass it as an explicit parameter to every function.</li> <li>Factory for Dynamic Resolution (<code>_storage_factory</code>): A factory function (<code>_storage_factory</code>) is registered for the <code>IBlobStorage</code> interface. This factory dynamically determines which concrete storage implementation to provide based on the current tenant's configuration (retrieved via <code>IConfiguration</code> and the <code>_current_tenant</code> context variable).</li> <li>Service Lifetimes: Careful selection of service lifetimes is crucial:<ul> <li><code>IClock</code>: Registered as a singleton. A single clock instance is shared across the entire application.</li> <li><code>DataIngestionService</code>: Registered as scoped. A new instance is created for each logical request or operation scope (in this case, per tenant request).     !!! info \"Why is <code>DataIngestionService</code> Scoped and Not Singleton?\"         If <code>DataIngestionService</code> were a singleton, the DI container would create it once. When created, it would be injected with an <code>IBlobStorage</code> instance. Due to the factory logic, this would be the storage backend for the very first tenant whose request was processed. Subsequent requests for other tenants would erroneously reuse this same backend (e.g., all tenants' data might end up in ACME's S3 bucket). By making <code>DataIngestionService</code> scoped, a new instance is created within each tenant's request scope, ensuring it gets an <code>IBlobStorage</code> instance appropriate for that specific tenant.</li> <li><code>IBlobStorage</code>: Registered with <code>add_transient_factory</code>. While the factory itself is called per resolution, the <code>DataIngestionService</code> being scoped means it gets its <code>IBlobStorage</code> once per scope. If <code>DataIngestionService</code> were transient, <code>IBlobStorage</code> (and its factory) would be resolved anew each time <code>DataIngestionService</code> was resolved.</li> </ul> </li> </ol>"},{"location":"advanced-examples/multi-tenant-ingestion/#application-workflow","title":"Application Workflow","text":"<ol> <li>Startup: The main process initializes the <code>ServiceCollection</code> with all necessary service registrations and builds the root <code>ServiceProvider</code>.</li> <li>Per Request (Simulated):<ol> <li>The <code>handle_request</code> function simulates an incoming request for a specific tenant.</li> <li>The <code>_current_tenant</code> <code>ContextVar</code> is set to the ID of the tenant for the current request.</li> <li>A new DI scope is created using <code>provider.create_scope()</code>. This ensures that any scoped services (like <code>DataIngestionService</code>) are fresh for this request.</li> <li><code>DataIngestionService</code> is resolved from the current scope. During its resolution:<ul> <li>The DI container needs an <code>IBlobStorage</code>.</li> <li>It calls the registered factory for <code>IBlobStorage</code> (<code>_storage_factory</code>).</li> <li>The factory uses the <code>ServiceProvider</code> (<code>sp</code>) to get <code>IConfiguration</code> and the current tenant ID (from <code>_current_tenant.get()</code>) to determine the correct backend type (S3, Azure, GCS).</li> <li>It then instantiates and returns the appropriate concrete storage implementation (e.g., <code>S3Storage</code>), injecting its dependencies (like <code>IClock</code>).</li> </ul> </li> <li>The <code>ingest</code> method of the <code>DataIngestionService</code> is called to process the file, using the correctly injected tenant-specific storage backend.</li> <li>Upon exiting the <code>with provider.create_scope() as scope:</code> block, the scope is disposed of. Any disposable scoped services would also be disposed.</li> </ol> </li> </ol> <p>This example is designed to be dependency-free for demonstration purposes; the \"cloud\" storage backends are simple in-memory classes. You can run <code>python examples/complex_ingest/app.py</code> (assuming the example structure) to see it in action.</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#implementation","title":"Implementation","text":"<p>a complete runable implementation can be found in <code>examples/complex_ingest</code></p> <p>```python from contextvars import ContextVar from typing import Dict, Callable, Type</p> <p>from wd.di import ServiceCollection from wd.di.config import Configuration, IConfiguration</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#placeholder-interfacesclasses-for-self-contained-documentation","title":"Placeholder interfaces/classes for self-contained documentation","text":"<p>class IClock:     def now(self): ...</p> <p>class IBlobStorage:     def upload(self, blob_name: str, data: bytes): ...</p> <p>class UtcClock(IClock):     def now(self): return \"current_time_utc\" # Simplified</p> <p>class S3Storage(IBlobStorage):     def init(self, clock: IClock): self._clock = clock     def upload(self, blob_name: str, data: bytes): print(f\"S3: Uploading {blob_name} at {self._clock.now()} ({len(data)} bytes)\")</p> <p>class AzureBlobStorage(IBlobStorage):     def init(self, clock: IClock): self._clock = clock     def upload(self, blob_name: str, data: bytes): print(f\"Azure: Uploading {blob_name} at {self._clock.now()} ({len(data)} bytes)\")</p> <p>class GcsStorage(IBlobStorage):     def init(self, clock: IClock): self._clock = clock     def upload(self, blob_name: str, data: bytes): print(f\"GCS: Uploading {blob_name} at {self._clock.now()} ({len(data)} bytes)\")</p> <p>class DataIngestionService:     def init(self, storage: IBlobStorage):         self._storage = storage     def ingest(self, filename: str, data: bytes):         print(f\"DataIngestionService: Ingesting {filename}\")         self._storage.upload(filename, data)</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#1-set-up-the-service-collection","title":"1. Set up the service collection","text":"<p>services = ServiceCollection() services.add_singleton(IClock, UtcClock) services.add_scoped(DataIngestionService)</p> <p>services.add_singleton_factory(     IConfiguration,     lambda _: Configuration(         {             \"tenants\": {                 \"ACME\": {\"backend\": \"s3\"},                 \"Contoso\": {\"backend\": \"azure\"},                 \"Globex\": {\"backend\": \"gcs\"},             }         }     ), )</p> <p>_current_tenant: ContextVar[str] = ContextVar(\"tenant\")</p> <p>def _storage_factory(sp, tenant_id: str) -&gt; IBlobStorage:     backend = sp.get_service(IConfiguration).get(f\"tenants:{tenant_id}:backend\")     mapping: Dict[str, Callable[[IClock], IBlobStorage]] = {         \"s3\": lambda clock: S3Storage(clock),         \"azure\": lambda clock: AzureBlobStorage(clock),         \"gcs\": lambda clock: GcsStorage(clock),     }     if backend not in mapping:         raise ValueError(f\"Unknown backend \\'{backend}\\' for tenant {tenant_id}\")     return mappingbackend</p> <p>services.add_transient_factory(     IBlobStorage, lambda sp: _storage_factory(sp, _current_tenant.get()) )</p> <p>provider = services.build_service_provider()</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#2-request-boundary-helper","title":"2. Request boundary helper","text":"<p>def handle_request(tenant_id: str, filename: str, data: bytes) -&gt; None:     token = _current_tenant.set(tenant_id)     with provider.create_scope() as scope:         scope.get_service(DataIngestionService).ingest(filename, data)     _current_tenant.reset(token)</p>"},{"location":"advanced-examples/multi-tenant-ingestion/#3-demo-run","title":"3. Demo run","text":"<p>if name == \"main\":     dummy_data = b\"dummy file content\"     print(\"--- Simulating ACME request ---\")     handle_request(\"ACME\", \"acme/lucy.jpg\", dummy_data)     print(\"\\n--- Simulating Contoso request ---\")     handle_request(\"Contoso\", \"contoso/luna.jpg\", dummy_data)     print(\"\\n--- Simulating Globex request ---\")     handle_request(\"Globex\", \"globex/lucy.jpg\", dummy_data)</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed documentation for the public API of the WD-DI library.</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>ServiceCollection: For registering services.</li> <li>ServiceProvider &amp; Scope: For resolving services and managing scopes.</li> <li>ServiceLifetime: Defines service lifetime options.</li> <li>create_service_collection(): Helper to create a <code>ServiceCollection</code>.</li> </ul>"},{"location":"api/#middleware","title":"Middleware","text":"<ul> <li>Middleware Components: Describes <code>IMiddleware</code>, <code>MiddlewarePipeline</code>, and built-in middleware.</li> <li>Middleware DI Integration: Covers <code>ApplicationBuilder</code> and <code>MiddlewareBuilder</code> for setting up middleware pipelines with DI.</li> </ul>"},{"location":"api/#configuration","title":"Configuration","text":"<ul> <li>Configuration System: Details <code>IConfiguration</code>, <code>ConfigurationBuilder</code>, and <code>Options</code>.</li> </ul>"},{"location":"api/#other","title":"Other","text":"<ul> <li>Descriptors: Service descriptor definitions.</li> <li>Exceptions: Custom exceptions. </li> </ul>"},{"location":"api/config/","title":"Configuration API","text":""},{"location":"api/config/#wd.di.config.IConfiguration","title":"<code>wd.di.config.IConfiguration</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/config/#wd.di.config.Options","title":"<code>wd.di.config.Options</code>","text":"<p>               Bases: <code>Generic[T]</code></p>"},{"location":"api/config/#wd.di.config.OptionsBuilder","title":"<code>wd.di.config.OptionsBuilder</code>","text":"<p>               Bases: <code>Generic[T]</code></p>"},{"location":"api/container/","title":"Container API","text":""},{"location":"api/container/#wd.di.container.ServiceProvider","title":"<code>wd.di.container.ServiceProvider</code>","text":""},{"location":"api/container/#wd.di.container.ServiceProvider.create_scope","title":"<code>create_scope()</code>","text":"<p>Return a scoped provider that shares singletons with the root.</p>"},{"location":"api/container/#wd.di.container.ServiceProvider.dispose","title":"<code>dispose()</code>","text":"<p>Dispose all tracked scoped instances (close / dispose).</p>"},{"location":"api/container/#wd.di.container.ServiceProvider.get_service","title":"<code>get_service(service_type)</code>","text":"<pre><code>get_service(service_type: Type[T]) -&gt; T\n</code></pre><pre><code>get_service(service_type: Type[Any]) -&gt; Any\n</code></pre> <p>Resolve service_type, creating &amp; caching it as needed.</p>"},{"location":"api/container/#wd.di.container.Scope","title":"<code>wd.di.container.Scope = ServiceProvider</code>  <code>module-attribute</code>","text":""},{"location":"api/create_service_collection/","title":"create_service_collection API","text":""},{"location":"api/create_service_collection/#wd.di.create_service_collection","title":"<code>wd.di.create_service_collection()</code>","text":"<p>Return a brand-new, empty service collection.</p>"},{"location":"api/descriptors/","title":"Descriptors API","text":""},{"location":"api/descriptors/#wd.di.descriptors.ServiceDescriptor","title":"<code>wd.di.descriptors.ServiceDescriptor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Immutable description of a service registration.</p>"},{"location":"api/descriptors/#wd.di.descriptors.ServiceDescriptor--attributes","title":"Attributes","text":"<p>service_type:     The abstraction that clients request\u2014usually an interface or base class. implementation_type:     The concrete class that will be instantiated to satisfy the registration.     Mutually exclusive with factory. factory:     A callable that builds the instance given the current service provider.     Mutually exclusive with implementation_type. lifetime:     Controls how long the resulting object lives (transient, scoped, singleton). decorators:     An ordered list of :data:<code>DecoratorFactory</code> objects to be applied to the     instance after construction but before lifetime caching.</p>"},{"location":"api/descriptors/#wd.di.descriptors.ServiceDescriptor.with_decorator","title":"<code>with_decorator(decorator)</code>","text":"<p>Return a new descriptor with decorator appended to the chain.</p> <p>The method does not modify the original object (dataclass is frozen) but returns a new instance that shares all existing attributes.</p>"},{"location":"api/descriptors/#wd.di.descriptors.DecoratorFactory","title":"<code>wd.di.descriptors.DecoratorFactory = Callable[['ServiceProvider', Any], Any]</code>  <code>module-attribute</code>","text":"<p>Callable that takes the current :class:<code>~wd.di.container.ServiceProvider</code> and the inner instance and returns a (possibly) wrapped instance.  The return type is Any on purpose to allow the decorator to change the runtime subtype while still respecting the semantic contract of T at the call site.</p>"},{"location":"api/exceptions/","title":"Exceptions API","text":""},{"location":"api/exceptions/#wd.di.exceptions.InvalidOperationError","title":"<code>wd.di.exceptions.InvalidOperationError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when an operation is not valid for the object\u2019s state.</p>"},{"location":"api/exceptions/#wd.di.exceptions.CircularDecoratorError","title":"<code>wd.di.exceptions.CircularDecoratorError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when a cycle in the decorator chain is detected.</p>"},{"location":"api/exceptions/#wd.di.exceptions.CircularDecoratorError--parameters","title":"Parameters","text":"<p>chain:     The list of decorator callables/classes involved in the cycle, in the     order they were traversed.</p>"},{"location":"api/lifetimes/","title":"Lifetimes API","text":""},{"location":"api/lifetimes/#wd.di.lifetimes.ServiceLifetime","title":"<code>wd.di.lifetimes.ServiceLifetime</code>","text":""},{"location":"api/middleware/","title":"Middleware Core API","text":""},{"location":"api/middleware/#wd.di.middleware.IMiddleware","title":"<code>wd.di.middleware.IMiddleware</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base interface for middleware components.</p>"},{"location":"api/middleware/#wd.di.middleware.IMiddleware.invoke","title":"<code>invoke(context, next)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Process the context and call the next middleware in the pipeline.</p>"},{"location":"api/middleware/#wd.di.middleware.MiddlewarePipeline","title":"<code>wd.di.middleware.MiddlewarePipeline</code>","text":"<p>Manages the middleware pipeline execution.</p>"},{"location":"api/middleware/#wd.di.middleware.MiddlewarePipeline.execute","title":"<code>execute(context)</code>  <code>async</code>","text":"<p>Execute the middleware pipeline.</p>"},{"location":"api/middleware/#wd.di.middleware.MiddlewarePipeline.use","title":"<code>use(middleware)</code>","text":"<p>Add a middleware to the pipeline.</p>"},{"location":"api/middleware/#wd.di.middleware.MiddlewarePipeline.use_middleware","title":"<code>use_middleware(middleware_class, instance=None)</code>","text":"<p>Add a middleware class to the pipeline.</p>"},{"location":"api/middleware/#wd.di.middleware.ExceptionHandlerMiddleware","title":"<code>wd.di.middleware.ExceptionHandlerMiddleware</code>","text":"<p>               Bases: <code>IMiddleware</code></p> <p>Built-in middleware for handling exceptions in the pipeline.</p>"},{"location":"api/middleware/#wd.di.middleware.LoggingMiddleware","title":"<code>wd.di.middleware.LoggingMiddleware</code>","text":"<p>               Bases: <code>IMiddleware</code></p> <p>Built-in middleware for logging pipeline execution.</p>"},{"location":"api/middleware/#wd.di.middleware.ValidationMiddleware","title":"<code>wd.di.middleware.ValidationMiddleware</code>","text":"<p>               Bases: <code>IMiddleware</code></p> <p>Built-in middleware for context validation.</p>"},{"location":"api/middleware/#wd.di.middleware.CachingMiddleware","title":"<code>wd.di.middleware.CachingMiddleware</code>","text":"<p>               Bases: <code>IMiddleware</code></p> <p>Built-in middleware for caching pipeline results.</p>"},{"location":"api/middleware/#wd.di.middleware.TNext","title":"<code>wd.di.middleware.TNext = Callable[[], Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/middleware/#wd.di.middleware.TMiddleware","title":"<code>wd.di.middleware.TMiddleware = Callable[[T, TNext], Any]</code>  <code>module-attribute</code>","text":""},{"location":"api/middleware_di/","title":"Middleware DI API","text":""},{"location":"api/middleware_di/#wd.di.middleware_di.MiddlewareBuilder","title":"<code>wd.di.middleware_di.MiddlewareBuilder</code>","text":"<p>Builder for configuring middleware in the DI container.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.MiddlewareBuilder.build","title":"<code>build()</code>","text":"<p>Build the middleware pipeline.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.MiddlewareBuilder.use","title":"<code>use(middleware)</code>","text":"<p>Add a middleware function to the pipeline.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.MiddlewareBuilder.use_middleware","title":"<code>use_middleware(middleware_type)</code>","text":"<p>Add a middleware class to the pipeline.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.ApplicationBuilder","title":"<code>wd.di.middleware_di.ApplicationBuilder</code>","text":"<p>Builder for configuring the application with middleware support.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.ApplicationBuilder.build","title":"<code>build()</code>","text":"<p>Build the application.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.ApplicationBuilder.configure_middleware","title":"<code>configure_middleware(configure)</code>","text":"<p>Configure the middleware pipeline.</p>"},{"location":"api/middleware_di/#wd.di.middleware_di.create_application_builder","title":"<code>wd.di.middleware_di.create_application_builder(services)</code>","text":"<p>Create an application builder for the service collection.</p>"},{"location":"api/service_collection/","title":"ServiceCollection API","text":""},{"location":"api/service_collection/#wd.di.service_collection.ServiceCollection","title":"<code>wd.di.service_collection.ServiceCollection</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Collects :class:<code>~wd.di.descriptors.ServiceDescriptor</code> objects and builds a provider.</p>"},{"location":"api/service_collection/#wd.di.service_collection.ServiceCollection.add_instance","title":"<code>add_instance(service_type, instance)</code>","text":"<p>Register an already\u2011constructed singleton instance.</p>"},{"location":"api/service_collection/#wd.di.service_collection.ServiceCollection.configure","title":"<code>configure(options_type, *, section=None)</code>","text":"<p>Bind options_type from the shared :pydata:<code>IConfiguration</code> instance.</p> <p><code>services.configure(MySettings)</code> automatically registers <code>Options[MySettings]</code> as a singleton whose value is built by binding MySettings against the configuration tree at provider\u2011build time.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>This section covers the fundamental principles and features of WD-DI.</p> <ul> <li>Separation of Concerns</li> <li>Component-Based Design</li> <li>Constructor Injection</li> <li>Service Lifetimes</li> <li>Configuration &amp; Options </li> </ul>"},{"location":"core-concepts/component-based-design/","title":"Component-Based Design with Interfaces and Lifetimes","text":"<p>Component-based design focuses on building systems from loosely coupled, replaceable parts (components). In the context of DI, this often involves defining clear interfaces (contracts) for your services and then providing concrete implementations for these interfaces. Managing the lifetime of these components is also a crucial aspect.</p>"},{"location":"core-concepts/component-based-design/#interface-driven-development","title":"Interface-Driven Development","text":"<p>Principle: Define interfaces (typically Abstract Base Classes - ABCs in Python) for your services. Register your concrete service implementations against these interfaces. This allows you to easily swap out implementations (e.g., for different environments or for testing) without changing the code that uses the service.</p> <p>Example:</p> <pre><code>from abc import ABC, abstractmethod\nfrom wd.di import create_service_collection\n\n# Create a service collection instance\nsc = create_service_collection()\n\n# Define an interface for user repository\nclass IUserRepository(ABC):\n    @abstractmethod\n    def get_user(self, user_id: str) -&gt; dict:\n        pass\n\n# Implementation of the repository interface\n@sc.singleton(IUserRepository) # Register UserRepository as the singleton for IUserRepository\nclass UserRepository(IUserRepository):\n    def get_user(self, user_id: str) -&gt; dict:\n        # In a real app, this would fetch from a database\n        print(f\"UserRepository: Getting user {user_id}\")\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n# Another possible implementation (e.g., for testing or a different data source)\n# Note: To use a named registration or switch implementations, you might need\n# to manage multiple ServiceCollection instances or clear and re-register for tests.\n# Standard resolution gets the last registered default for an interface.\n@sc.singleton(IUserRepository) # This would overwrite the previous registration for IUserRepository\nclass MockUserRepository(IUserRepository):\n    def get_user(self, user_id: str) -&gt; dict:\n        print(f\"MockUserRepository: Getting user {user_id}\")\n        return {\"id\": user_id, \"name\": \"Mock User\"}\n\n# --- Usage ---\n# If MockUserRepository was registered last, it will be the one resolved:\nprovider = sc.build_service_provider()\nuser_repo = provider.get_service(IUserRepository)\nprint(user_repo.get_user(\"123\"))\n# Expected output if MockUserRepository was last:\n# MockUserRepository: Getting user 123\n# {'id': '123', 'name': 'Mock User'}\n\n# To truly switch, you'd typically manage registrations carefully:\nsc_default = create_service_collection()\n@sc_default.singleton(IUserRepository)\nclass RealUserRepository(IUserRepository):\n    def get_user(self, user_id: str) -&gt; dict:\n        return {\"id\": user_id, \"name\": \"Real User from DB\"}\n\nsc_test = create_service_collection()\n@sc_test.singleton(IUserRepository)\nclass TestDoubleUserRepository(IUserRepository):\n    def get_user(self, user_id: str) -&gt; dict:\n        return {\"id\": user_id, \"name\": \"Test User via Double\"}\n\n# In app code:\n# provider_real = sc_default.build_service_provider()\n# repo_real = provider_real.get_service(IUserRepository)\n\n# In test code:\n# provider_test = sc_test.build_service_provider()\n# repo_test = provider_test.get_service(IUserRepository)\n</code></pre> <p>When to use Interface-Driven Development: Always prefer to code against interfaces rather than concrete implementations when a component is likely to have multiple implementations (e.g., for different data sources, different external services) or when you want to improve testability by easily mocking dependencies.</p>"},{"location":"core-concepts/component-based-design/#lifetimes-matter","title":"Lifetimes Matter","text":"<p>Principle: Select service lifetimes based on the nature of the dependency and how it should be shared:</p> <ul> <li><code>@sc.transient()</code> (Transient): A new instance of the service is created every time it is requested from the service provider or injected as a dependency.<ul> <li>Use for: Lightweight, stateless services or services that should not share state between different consumers within the same scope or across scopes.</li> </ul> </li> <li><code>@sc.singleton()</code> (Singleton): Only one instance of the service is created for the entire lifetime of the service provider (application). This single instance is shared across all requests and scopes.<ul> <li>Use for: Services that are expensive to create, stateless utility services, or services that need to maintain a global application state (use with caution for shared mutable state).</li> </ul> </li> <li><code>@sc.scoped()</code> (Scoped): A new instance of the service is created once per scope. Within the same scope (e.g., a web request, or a manually created scope via <code>provider.create_scope()</code>), the same instance is reused. Different scopes will get different instances.<ul> <li>Use for: Services that need to maintain state for a specific unit of work (like a web request or a transaction) but should be isolated between different units of work. Examples include database session/connection objects, or services holding request-specific cache.</li> </ul> </li> </ul> <p>Example (Conceptual Registration):</p> <pre><code>from wd.di import create_service_collection\n# For demonstration, assume IService and various implementations are defined.\n# class IService:\n#     def do_work(self): raise NotImplementedError\n# class MyTransientServiceImpl(IService): \n#     def __init__(self): print(f\"{type(self).__name__} created\")\n#     def do_work(self): print(f\"{type(self).__name__} working\")\n# class MySingletonServiceImpl(IService):\n#     def __init__(self): print(f\"{type(self).__name__} created\")\n#     def do_work(self): print(f\"{type(self).__name__} working\")\n# class MyScopedServiceImpl(IService):\n#     def __init__(self): print(f\"{type(self).__name__} created\")\n#     def do_work(self): print(f\"{type(self).__name__} working\")\n\nsc = create_service_collection()\n\n# Manual registration (less common now with decorators but still possible):\n# sc.add_transient(IService, MyTransientServiceImpl)\n# sc.add_singleton(IService, MySingletonServiceImpl)\n# sc.add_scoped(IService, MyScopedServiceImpl)\n\n# Using decorators (preferred):\n# @sc.transient(IService)\n# class DecoratedTransient(IService): ...\n\n# @sc.singleton(IService)\n# class DecoratedSingleton(IService): ...\n\n# @sc.scoped(IService)\n# class DecoratedScoped(IService): ...\n\n# If decorating the class itself as the service type:\n# @sc.transient()\n# class MyPlainTransientService:\n#     def __init__(self): print(f\"{type(self).__name__} created\")\n#     def do_work(self): print(f\"{type(self).__name__} working\")\n</code></pre> <p>When to Choose Lifetimes: Carefully consider the statefulness and resource implications of your services.  - Use transient for stateless services or those needing unique instances. - Use singleton for shared, stateless utilities or for managing global state carefully. - Use scoped for services that need to maintain state within a specific unit of work (like a request) and be disposed of afterward. </p>"},{"location":"core-concepts/configuration/","title":"Configuration and Options Pattern","text":"<p>WD-DI includes a robust configuration system inspired by .NET's Options pattern. This allows you to bind configuration data (from dictionaries, JSON files, environment variables, etc., though currently focused on dictionary sources) to strongly-typed Python dataclasses. This approach centralizes configuration logic, provides type safety, and makes configuration access clean and maintainable.</p>"},{"location":"core-concepts/configuration/#key-components","title":"Key Components","text":"<ul> <li><code>IConfiguration</code>: An interface (and its concrete implementation <code>Configuration</code>) that represents your application's configuration. It can load data from a dictionary and provides methods to access configuration sections.</li> <li>**<code>Options[T]:** A generic wrapper class. When you request</code>Options[MyConfigClass], WD-DI provides an instance of <code>Options</code> whose <code>value</code> attribute holds a populated instance of <code>MyConfigClass</code>.</li> <li><code>services.configure(ConfigClass, section_name)</code>: A method on <code>ServiceCollection</code> used to bind a section of your application's configuration (retrieved from <code>IConfiguration</code>) to a specific dataclass (<code>ConfigClass</code>).</li> </ul>"},{"location":"core-concepts/configuration/#how-it-works","title":"How It Works","text":"<ol> <li>Define an Options Dataclass: Create a Python dataclass that represents the structure of a particular configuration section.     <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass DatabaseOptions:\n    connection_string: str = \"\"\n    max_connections: int = 10\n    timeout: int = 30\n</code></pre></li> <li>Provide Configuration Data: Create a configuration source. Typically, this is a dictionary, which could be loaded from a JSON file, environment variables, or constructed in code.     <pre><code>config_data = {\n    \"Database\": {  # Section name (case-insensitive by default in GetSection)\n        \"ConnectionString\": \"your_db_connection_string\",\n        \"MaxConnections\": 50\n        # Timeout will use the default from DatabaseOptions (30)\n    },\n    \"Logging\": {\n        \"Level\": \"Information\"\n    }\n}\n</code></pre></li> <li>Register <code>IConfiguration</code>: Add your configuration object (an instance of <code>Configuration</code> or your custom <code>IConfiguration</code> implementation) to the service collection, usually as a singleton.     <pre><code>from wd.di import create_service_collection\nfrom wd.di.config import Configuration, IConfiguration\n\nsc = create_service_collection()\napp_config = Configuration(config_data)\nsc.add_singleton_factory(IConfiguration, lambda _: app_config)\n</code></pre></li> <li>Bind Configuration to Options: Use <code>sc.configure()</code> to tell WD-DI how to map a configuration section to your options dataclass.     <pre><code>sc.configure(DatabaseOptions, section=\"Database\")\n</code></pre>     This tells WD-DI: \"When <code>Options[DatabaseOptions] is requested, find the 'Database' section in</code>IConfiguration<code>, create an instance of</code>DatabaseOptions`, and populate it with data from that section (automatically converting PascalCase/camelCase keys from config to snake_case attributes in the dataclass).\"</li> <li>**Inject <code>Options[T] into Services:** In your services, depend on</code>Options[YourConfigClass] to access the configured values.     <pre><code>from wd.di.config import Options\n\n@sc.singleton()\nclass DatabaseService:\n    def __init__(self, db_options: Options[DatabaseOptions]):\n        self.options = db_options.value # Access the populated dataclass instance\n        print(f\"DB Connection: {self.options.connection_string}\")\n        print(f\"DB Max Connections: {self.options.max_connections}\")\n        print(f\"DB Timeout: {self.options.timeout}\") # Will be 30 (default)\n\n# --- Usage ---\nprovider = sc.build_service_provider()\ndb_service = provider.get_service(DatabaseService)\n# Expected Output:\n# DB Connection: your_db_connection_string\n# DB Max Connections: 50\n# DB Timeout: 30\n</code></pre></li> </ol>"},{"location":"core-concepts/configuration/#benefits-of-the-options-pattern","title":"Benefits of the Options Pattern","text":"<ul> <li>Strong Typing: Configuration is accessed via dataclasses, providing attribute access and type checking (if using static analysis). This reduces errors caused by typos in string-based dictionary lookups.</li> <li>Centralization: Configuration logic is defined in one place (your options dataclasses and the <code>configure</code> calls).</li> <li>Decoupling: Services depend on <code>Options[T] rather than directly on</code>IConfiguration<code>or concrete configuration sources. This makes services more testable, as you can easily provide mock</code>Options` in tests.</li> <li>Default Values: Dataclasses allow you to specify default values for configuration properties, simplifying setup for common scenarios.</li> <li>Clear Structure: Configuration is organized into logical sections represented by different options classes.</li> </ul>"},{"location":"core-concepts/configuration/#when-to-use","title":"When to Use","text":"<ul> <li>For any application settings that might vary between environments (development, staging, production) or need to be managed externally.</li> <li>When you want to provide type-safe access to configuration values within your services.</li> <li>To keep your services decoupled from the specifics of how configuration is loaded and stored.</li> </ul> <p>The Options pattern is a powerful tool for managing application settings in a clean, robust, and maintainable way.</p>"},{"location":"core-concepts/constructor-injection/","title":"Constructor Injection","text":"<p>Constructor injection is the primary mechanism by which WD-DI manages and provides dependencies to your services. When a service is resolved, WD-DI inspects its constructor (<code>__init__</code> method), identifies the required dependencies based on type hints, and automatically supplies instances of those dependencies.</p> <p>This pattern promotes clear, testable, and maintainable code by making a class's dependencies explicit in its constructor signature.</p>"},{"location":"core-concepts/constructor-injection/#how-it-works","title":"How It Works","text":"<ol> <li>Service Registration: You register your services (e.g., <code>DatabaseService</code>, <code>UserService</code>) with the <code>ServiceCollection</code>, specifying their lifetimes.</li> <li>Type Hinting: Your service constructors must use type hints for their parameters (e.g., <code>db_service: DatabaseService</code>). WD-DI uses these hints to know which registered service to inject.</li> <li>Resolution: When you request a service (e.g., <code>provider.get_service(UserService)</code>), WD-DI:<ul> <li>Finds the registered entry for <code>UserService</code>.</li> <li>Inspects its <code>__init__</code> method.</li> <li>Sees it needs a <code>DatabaseService</code>.</li> <li>Resolves an instance of <code>DatabaseService</code> (according to its registered lifetime).</li> <li>Instantiates <code>UserService</code>, passing the <code>DatabaseService</code> instance into its constructor.</li> <li>Returns the fully constructed <code>UserService</code> instance.</li> </ul> </li> </ol>"},{"location":"core-concepts/constructor-injection/#example","title":"Example","text":"<p>Let's consider a <code>UserService</code> that depends on a <code>DatabaseService</code>.</p> <pre><code>from wd.di import ServiceCollection\n\nservices = ServiceCollection()\n\n# Assume DatabaseService is defined and registered, for example:\n# (This could be an interface IUserService or a concrete class)\nclass IDatabaseService: # Using an interface for demonstration\n    def query(self, sql: str):\n        raise NotImplementedError\n\n@services.singleton(IDatabaseService) # Registering concrete type for the interface\nclass ConcreteDatabaseService(IDatabaseService):\n    def __init__(self):\n        print(\"ConcreteDatabaseService created (singleton)\")\n\n    def query(self, sql: str):\n        print(f\"Executing query: {sql}\")\n        return [{\"id\": 1, \"name\": \"Test User\"}] # Dummy data\n\n# UserService depends on IDatabaseService\n@services.singleton() # UserService itself can be a singleton or other lifetime\nclass UserService:\n    def __init__(self, db_service: IDatabaseService): # Dependency is type-hinted\n        print(\"UserService created, injecting IDatabaseService.\")\n        self.db = db_service\n\n    def get_user_data(self, user_id: int):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n# --- Usage ---\n# Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve the UserService\n# WD-DI will automatically create and inject ConcreteDatabaseService\nuser_service = provider.get_service(UserService)\n\n# Use the service\nuser_data = user_service.get_user_data(user_id=1)\nprint(f\"User data retrieved: {user_data}\")\n\n# If you resolve IDatabaseService directly, you get the same singleton instance\ndb_instance = provider.get_service(IDatabaseService)\nprint(f\"Is user_service.db the same as db_instance? {user_service.db is db_instance}\")\n\n# Expected Output:\n# ConcreteDatabaseService created (singleton)\n# UserService created, injecting IDatabaseService.\n# Executing query: SELECT * FROM users WHERE id = 1\n# User data retrieved: [{'id': 1, 'name': 'Test User'}]\n# Is user_service.db the same as db_instance? True\n</code></pre> <p>In this example: *   <code>ConcreteDatabaseService</code> is registered as a singleton for the <code>IDatabaseService</code> interface. *   <code>UserService</code> declares its dependency on <code>IDatabaseService</code> in its constructor. *   When <code>UserService</code> is resolved, WD-DI provides the singleton instance of <code>ConcreteDatabaseService</code>.</p>"},{"location":"core-concepts/constructor-injection/#benefits-of-constructor-injection","title":"Benefits of Constructor Injection","text":"<ul> <li>Explicit Dependencies: A class's dependencies are clearly listed in its constructor signature, making the class's requirements easy to understand.</li> <li>Improved Testability: When unit testing, you can easily pass mock or stub implementations of dependencies directly to the constructor, isolating the class under test. For example:     <pre><code># --- Defining services (simplified for testability example) ---\nfrom abc import ABC, abstractmethod\n\nclass IEmailService(ABC):\n    @abstractmethod\n    def send_email(self, recipient: str, subject: str, body: str):\n        pass\n\nclass UserService:\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    def notify_user(self, user_id: str, message: str):\n        # In a real app, fetch user's email, etc.\n        email_address = f\"{user_id}@example.com\"\n        self.email_service.send_email(email_address, \"Notification\", message)\n\n# --- Test with a mock --- \nclass MockEmailService(IEmailService):\n    def __init__(self):\n        self.sent_emails = []\n\n    def send_email(self, recipient: str, subject: str, body: str):\n        print(f\"MOCK: Sending email to {recipient} - Subject: {subject}\")\n        self.sent_emails.append({\"to\": recipient, \"subject\": subject, \"body\": body})\n\ndef test_user_service_notification():\n    mock_mailer = MockEmailService()\n    # Manually inject the mock when creating UserService for the test\n    user_service_for_test = UserService(email_service=mock_mailer)\n\n    user_service_for_test.notify_user(\"testuser\", \"Your item has shipped!\")\n\n    assert len(mock_mailer.sent_emails) == 1\n    assert mock_mailer.sent_emails[0][\"to\"] == \"testuser@example.com\"\n    assert mock_mailer.sent_emails[0][\"body\"] == \"Your item has shipped!\"\n    print(\"Test passed: UserService correctly used the mock email service.\")\n\n# To run the test (typically done by a test runner like pytest):\n# test_user_service_notification()\n</code></pre></li> <li>Loose Coupling: Classes don't create their dependencies; they receive them. This reduces coupling between components.</li> <li>Compile-Time Safety (with Type Hints): While Python is dynamically typed, type hints used for DI allow static analysis tools (like MyPy) to catch potential type mismatches early.</li> <li>Readability and Maintainability: Makes the flow of dependencies through your application easier to trace and manage.</li> </ul> <p>When to use:</p> <p>Always prefer constructor injection for mandatory dependencies. It's the cleanest and most straightforward way to implement Inversion of Control and Dependency Injection. WD-DI is designed primarily around this pattern. </p>"},{"location":"core-concepts/lifetimes/","title":"Service Lifetimes","text":"<p>Service lifetimes define how instances of services are created, shared, and disposed of by the <code>ServiceProvider</code>. WD-DI supports three distinct lifetimes, allowing you to control the instantiation behavior of your registered services precisely.</p> <p>Choosing the correct lifetime is crucial for managing resources efficiently and ensuring predictable behavior in your application.</p>"},{"location":"core-concepts/lifetimes/#transient","title":"Transient","text":"<p>What is it? A new instance of a transient service is created every time it is requested from the service container. This is the default lifetime if none is specified (though explicit declaration is always clearer).</p> <p>Characteristics: *   Each call to <code>provider.get_service(MyTransientService)</code> or resolution of <code>MyTransientService</code> as a dependency will result in a brand-new object. *   Suitable for lightweight, stateless services where each consumer needs a unique instance.</p> <p>Example:</p> <pre><code>from wd.di import ServiceCollection\n\n# Assume IRequestProcessor and RequestProcessorImpl are defined\n# interface IRequestProcessor: ...\n# class RequestProcessorImpl(IRequestProcessor): ...\n\nservices = ServiceCollection()\n\n# Registering with explicit implementation type:\nservices.add_transient(IRequestProcessor, RequestProcessorImpl)\n\n# Or, using the decorator on the class itself (if it implements itself):\n@services.transient()\nclass UniqueOperationLogger:\n    def __init__(self):\n        import uuid\n        self.operation_id = uuid.uuid4()\n        print(f\"Logger {self.operation_id} created.\")\n\n    def log(self, message: str):\n        print(f\"[{self.operation_id}] {message}\")\n\n# --- Usage ---\nprovider = services.build_service_provider()\n\nlogger1 = provider.get_service(UniqueOperationLogger)\nlogger2 = provider.get_service(UniqueOperationLogger)\n\nprint(f\"Are loggers the same instance? {logger1 is logger2}\")\n# Expected Output:\n# Logger &lt;uuid1&gt; created.\n# Logger &lt;uuid2&gt; created.\n# Are loggers the same instance? False\n</code></pre> <p>When to use: *   Lightweight, stateless services. *   Services that need to be unique for each user or processing unit (e.g., a request-specific calculator). *   When you want to avoid any risk of shared state between different parts of your application using the same service type.</p>"},{"location":"core-concepts/lifetimes/#singleton","title":"Singleton","text":"<p>What is it? A single instance of a singleton service is created the first time it is requested (or when <code>build_service_provider</code> is called if pre-instantiation is configured, though WD-DI resolves lazily by default). This same instance is then shared across the entire application for all subsequent requests within the same service provider.</p> <p>Characteristics: *   The first resolution creates the instance; all subsequent resolutions return that same instance. *   Suitable for services that are expensive to create, maintain a shared state, or represent a global resource (e.g., application configuration, logging service, database connection pool manager).</p> <p>Example:</p> <pre><code>from wd.di import ServiceCollection\n\n# Assume IApplicationSettings and ApplicationSettingsImpl are defined\n# interface IApplicationSettings: ...\n# class ApplicationSettingsImpl(IApplicationSettings): def load_settings(self): print(\"Settings loaded.\")\n\nservices = ServiceCollection()\n\n# Registering with explicit implementation type:\nservices.add_singleton(IApplicationSettings, ApplicationSettingsImpl)\n\n# Or, using the decorator:\n@services.singleton()\nclass AppConfig:\n    def __init__(self):\n        print(\"AppConfig initialized (once).\")\n        self.api_key = \"my-secret-key\"\n\n# --- Usage ---\nprovider = services.build_service_provider()\n\nconfig1 = provider.get_service(AppConfig)\nconfig2 = provider.get_service(AppConfig)\n\nprint(f\"Config1 API Key: {config1.api_key}\")\nprint(f\"Are configs the same instance? {config1 is config2}\")\n# Expected Output:\n# AppConfig initialized (once).\n# Config1 API Key: my-secret-key\n# Are configs the same instance? True\n</code></pre> <p>When to use: *   Services that manage shared state (e.g., caches, application-wide counters). *   Services that are expensive to initialize and can be reused (e.g., HTTP clients with connection pooling, database access layers). *   Configuration objects or logging services. *   Caution: Be mindful of thread safety if the singleton service has mutable state that can be accessed concurrently.</p>"},{"location":"core-concepts/lifetimes/#scoped","title":"Scoped","text":"<p>What is it? A single instance of a scoped service is created for each defined \"scope.\" Within a given scope, all requests for the service will return the same instance. Different scopes will each get their own unique instance.</p> <p>Characteristics: *   WD-DI requires explicit scope creation using <code>provider.create_scope()</code>. *   Scoped services are typically created once per scope and disposed of when the scope ends (if they implement a <code>dispose()</code> or <code>close()</code> method). *   This lifetime is ideal for services that should share state within a specific unit of work (e.g., a web request, a transaction) but should be isolated between different units of work.</p> <p>Example:</p> <pre><code>from wd.di import ServiceCollection\n\n# Assume IUnitOfWork and UnitOfWorkImpl are defined\n# interface IUnitOfWork: ...\n# class UnitOfWorkImpl(IUnitOfWork): def __init__(self): print(\"UnitOfWork created for scope.\")\n\nservices = ServiceCollection()\n\n# Registering with explicit implementation type:\nservices.add_scoped(IUnitOfWork, UnitOfWorkImpl)\n\n# Or, using the decorator:\n@services.scoped()\nclass RequestContext:\n    def __init__(self):\n        import uuid\n        self.request_id = uuid.uuid4()\n        print(f\"RequestContext {self.request_id} created for current scope.\")\n\n# --- Usage ---\nprovider = services.build_service_provider()\n\nprint(\"--- Scope 1 ---\")\nwith provider.create_scope() as scope1:\n    context1_a = scope1.get_service(RequestContext)\n    context1_b = scope1.get_service(RequestContext)\n    print(f\"Are context1_a and context1_b the same? {context1_a is context1_b}\")\n\nprint(\"\\\\n--- Scope 2 ---\")\nwith provider.create_scope() as scope2:\n    context2_a = scope2.get_service(RequestContext)\n    context2_b = scope2.get_service(RequestContext)\n    print(f\"Are context2_a and context2_b the same? {context2_a is context2_b}\")\n    print(f\"Is context1_a the same as context2_a? {context1_a is context2_a}\")\n\n# Expected Output:\n# --- Scope 1 ---\n# RequestContext &lt;uuid1&gt; created for current scope.\n# Are context1_a and context1_b the same? True\n#\n# --- Scope 2 ---\n# RequestContext &lt;uuid2&gt; created for current scope.\n# Are context2_a and context2_b the same? True\n# Is context1_a the same as context2_a? False\n</code></pre> <p>When to use: *   Services that manage resources tied to a specific unit of work, like database connections or transaction contexts, ensuring proper setup and cleanup per scope. *   Services that need to maintain state for a particular operation or request but should not be shared globally. *   In web applications, often used for services per HTTP request.</p> <p>Understanding and correctly applying these service lifetimes is fundamental to building robust and efficient applications with WD-DI. </p>"},{"location":"core-concepts/separation-of-concerns/","title":"Separation of Concerns","text":"<p>Principle: Break your application into components with clear responsibilities. Use constructor injection to make dependencies explicit and decouple components.</p> <p>Example:</p> <pre><code>from wd.di import create_service_collection\n\n# Create a service collection instance\nsc = create_service_collection()\n\n# EmailService: A service responsible for sending emails\n@sc.singleton() # Registering EmailService as a singleton\nclass EmailService:\n    def send_email(self, recipient: str, subject: str, body: str):\n        print(f\"Sending email to {recipient} with subject '{subject}' and body '{body}'\")\n\n# UserService: Depends on EmailService for notifications\n@sc.singleton()\nclass UserService:\n    def __init__(self, email_service: EmailService):\n        self.email_service = email_service\n\n    def notify(self, user_id: str, message: str):\n        # In a real app, fetch user's email from a repository, etc.\n        email_address = f\"{user_id}@example.com\" # Example email\n        self.email_service.send_email(email_address, \"Notification\", message)\n\n# Register and use the services:\nprovider = sc.build_service_provider()\nuser_service = provider.get_service(UserService)\nuser_service.notify(\"user123\", \"Your order has shipped!\")\n\n# Expected Output:\n# Sending email to user123@example.com with subject 'Notification' and body 'Your order has shipped!'\n</code></pre> <p>When to use: Apply separation of concerns to keep business logic distinct from infrastructure (e.g., sending emails, logging), making your code easier to maintain and test. </p>"},{"location":"middleware/","title":"Middleware","text":"<p>This section explains how to use middleware in WD-DI to handle cross-cutting concerns.</p> <ul> <li>Overview</li> <li>Built-in Middleware </li> </ul>"},{"location":"middleware/built-ins/","title":"Built-in Middleware Components","text":"<p>WD-DI provides a few common middleware components out of the box to handle typical cross-cutting concerns. These can be used directly in your pipeline or serve as examples for creating your own custom middleware.</p> <p>You can find these middleware classes in the <code>wd.di.middleware</code> module.</p>"},{"location":"middleware/built-ins/#loggingmiddleware","title":"<code>LoggingMiddleware</code>","text":"<p>Purpose: Logs the start and completion of pipeline execution for a given context.</p> <p>How it works: *   Accepts a <code>logger</code> callable (e.g., <code>print</code>, or a method from Python's <code>logging</code> module) in its constructor. *   Before calling <code>await next()</code>, it logs a message like \"Executing pipeline for context: [context]\". *   After <code>await next()</code> completes, it logs a message like \"Pipeline for context: [context] completed with result: [result]\".</p> <p>Example Usage: <pre><code>from wd.di import ServiceCollection\nfrom wd.di.middleware import LoggingMiddleware, MiddlewarePipeline\n\n# Define a context and a simple final handler\nclass MyContext:\n    def __init__(self, data):\n        self.data = data\n    def __str__(self): # For logging\n        return f\"MyContext(data='{self.data}')\"\n\nclass FinalHandler:\n    async def invoke(self, context, next):\n        return f\"Processed: {context.data}\"\n\nservices = ServiceCollection()\napp_builder = services.create_application_builder()\n\n# Configure logging middleware (using print as the logger)\napp_builder.configure_middleware(lambda builder: (\n    builder\n    .use_middleware(lambda: LoggingMiddleware(logger_func=print)) # Pass the logger function\n    .use_middleware(FinalHandler)\n))\n\nprovider = app_builder.build()\npipeline = provider.get_service(MiddlewarePipeline)\n\n# import asyncio\n# asyncio.run(pipeline.execute(MyContext(\"test_data\")))\n# Expected Output (will vary slightly based on actual context string representation):\n# Executing pipeline for context: MyContext(data='test_data')\n# Pipeline for context: MyContext(data='test_data') completed with result: Processed: test_data\n</code></pre> Dependencies: *   Requires a `logger_func: Callable[[str], None] to be passed to its constructor. This function will be called with log messages.</p>"},{"location":"middleware/built-ins/#exceptionhandlermiddleware","title":"<code>ExceptionHandlerMiddleware</code>","text":"<p>Purpose: Centralizes error handling within the middleware pipeline. Catches exceptions from subsequent middleware and allows for custom error processing.</p> <p>How it works: *   Accepts an <code>exception_handler</code> callable in its constructor. This handler function should take the <code>context</code> and the <code>exception</code> as arguments. *   It wraps the <code>await next()</code> call in a <code>try...except</code> block. *   If an exception occurs, it calls the provided <code>exception_handler(context, exception)</code>. The return value of this handler becomes the result of the pipeline execution.</p> <p>Example Usage: <pre><code>from wd.di import ServiceCollection\nfrom wd.di.middleware import ExceptionHandlerMiddleware, MiddlewarePipeline\n\nclass MyContext:\n    def __init__(self, should_fail: bool):\n        self.should_fail = should_fail\n\nclass RiskyHandler:\n    async def invoke(self, context, next):\n        if context.should_fail:\n            raise ValueError(\"Something went wrong in RiskyHandler!\")\n        return \"RiskyHandler succeeded\"\n\ndef my_custom_error_handler(context, exception):\n    print(f\"Custom Error Handler: Caught {type(exception).__name__}: {exception} for context: {context}\")\n    return \"Default error response\"\n\nservices = ServiceCollection()\napp_builder = services.create_application_builder()\n\napp_builder.configure_middleware(lambda builder: (\n    builder\n    .use_middleware(lambda: ExceptionHandlerMiddleware(my_custom_error_handler))\n    .use_middleware(RiskyHandler)\n))\n\nprovider = app_builder.build()\npipeline = provider.get_service(MiddlewarePipeline)\n\n# import asyncio\n# async def main():\n#     success_context = MyContext(should_fail=False)\n#     result_success = await pipeline.execute(success_context)\n#     print(f\"Result (Success): {result_success}\")\n\n#     fail_context = MyContext(should_fail=True)\n#     result_fail = await pipeline.execute(fail_context)\n#     print(f\"Result (Fail): {result_fail}\")\n# asyncio.run(main())\n\n# Expected Output:\n# Result (Success): RiskyHandler succeeded\n# Custom Error Handler: Caught ValueError: Something went wrong in RiskyHandler! for context: &lt;__main__.MyContext object at 0x...&gt;\n# Result (Fail): Default error response\n</code></pre></p> <p>Dependencies: *   Requires an `exception_handler: Callable[[Any, Exception], Any] to be passed to its constructor.</p>"},{"location":"middleware/built-ins/#validationmiddleware","title":"<code>ValidationMiddleware</code>","text":"<p>Purpose: Validates the context object before allowing the pipeline to proceed.</p> <p>How it works: *   Accepts a <code>validator</code> callable in its constructor. This validator function should take the <code>context</code> as an argument and return <code>True</code> if valid, or <code>False</code> (or raise an exception) if invalid. *   If the <code>validator(context)</code> returns <code>False</code> or raises an error (by default, it raises <code>ValueError</code> if the validator returns <code>False</code>), the pipeline is short-circuited, and an exception is raised (or propagated).</p> <p>Example Usage: <pre><code>from wd.di import ServiceCollection\nfrom wd.di.middleware import ValidationMiddleware, MiddlewarePipeline\n\nclass MyContext:\n    def __init__(self, data: str):\n        self.data = data\n\nclass EchoHandler:\n    async def invoke(self, context, next):\n        return f\"Echo: {context.data}\"\n\ndef my_validator(context: MyContext) -&gt; bool:\n    is_valid = context.data is not None and len(context.data) &gt; 3\n    print(f\"Validating '{context.data}': {is_valid}\")\n    return is_valid\n\nservices = ServiceCollection()\napp_builder = services.create_application_builder()\n\napp_builder.configure_middleware(lambda builder: (\n    builder\n    .use_middleware(lambda: ValidationMiddleware(my_validator))\n    .use_middleware(EchoHandler)\n))\n\nprovider = app_builder.build()\npipeline = provider.get_service(MiddlewarePipeline)\n\n# import asyncio\n# async def main():\n#     valid_context = MyContext(\"valid_data\")\n#     result_valid = await pipeline.execute(valid_context)\n#     print(f\"Result (Valid): {result_valid}\")\n\n#     invalid_context = MyContext(\"bad\")\n#     try:\n#         await pipeline.execute(invalid_context)\n#     except ValueError as e:\n#         print(f\"Error (Invalid): {e}\")\n# asyncio.run(main())\n\n# Expected Output:\n# Validating 'valid_data': True\n# Result (Valid): Echo: valid_data\n# Validating 'bad': False\n# Error (Invalid): Context validation failed.\n</code></pre></p> <p>Dependencies: *   Requires a `validator: Callable[[Any], bool] to be passed to its constructor.</p>"},{"location":"middleware/built-ins/#cachingmiddleware","title":"<code>CachingMiddleware</code>","text":"<p>Purpose: Caches the result of the pipeline execution for a given context to avoid re-computation.</p> <p>How it works: *   Uses the <code>context</code> object itself as the cache key (so the context must be hashable). *   On first execution for a specific context, it calls <code>await next()</code> and stores the result in an in-memory dictionary. *   On subsequent executions with an identical (hash-equal) context, it returns the cached result directly without calling <code>await next()</code>.</p> <p>Example Usage: <pre><code>from wd.di import ServiceCollection\nfrom wd.di.middleware import CachingMiddleware, MiddlewarePipeline\nimport time\n\n# Make context hashable\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True) # frozen=True makes it hashable\nclass MyContext:\n    key: str\n\ncall_count = 0\nclass SlowHandler:\n    async def invoke(self, context, next):\n        nonlocal call_count\n        call_count += 1\n        print(f\"SlowHandler called (call #{call_count}) for key: {context.key}\")\n        await asyncio.sleep(0.1) # Simulate work\n        return f\"Processed: {context.key}\"\n\nservices = ServiceCollection()\napp_builder = services.create_application_builder()\n\napp_builder.configure_middleware(lambda builder: (\n    builder\n    .use_middleware(CachingMiddleware) # CachingMiddleware should usually be early in the pipeline\n    .use_middleware(SlowHandler)\n))\n\nprovider = app_builder.build()\npipeline = provider.get_service(MiddlewarePipeline)\n\n# import asyncio\n# async def main():\n#     context1 = MyContext(\"data_key_1\")\n#     print(await pipeline.execute(context1)) # First call, SlowHandler executes\n#     print(await pipeline.execute(context1)) # Second call, result is cached\n\n#     context2 = MyContext(\"data_key_2\")\n#     print(await pipeline.execute(context2)) # First call for this context, SlowHandler executes\n# asyncio.run(main())\n\n# Expected Output:\n# SlowHandler called (call #1) for key: data_key_1\n# Processed: data_key_1\n# Processed: data_key_1  (from cache, SlowHandler not called again for context1)\n# SlowHandler called (call #2) for key: data_key_2\n# Processed: data_key_2\n</code></pre></p> <p>Dependencies: *   None, beyond the context being hashable.</p> <p>These built-in middleware components provide a good starting point for handling common concerns. You can easily combine them with your own custom middleware to build sophisticated processing pipelines. </p>"},{"location":"middleware/overview/","title":"Middleware Pipeline Overview","text":"<p>WD-DI includes a flexible middleware pipeline that allows you to compose processing logic in a sequence. This pattern is particularly well-suited for handling cross-cutting concerns in your application\u2014functionality that applies to many parts of your system but isn't part of the core business logic of any single component.</p> <p>Think of a middleware pipeline as a series of processing steps that a request (or a context object representing that request) goes through. Each middleware component in the pipeline has the opportunity to:</p> <ul> <li>Inspect the request/context.</li> <li>Modify the request/context.</li> <li>Perform actions before or after the next middleware in the pipeline is called.</li> <li>Short-circuit the pipeline and return a response immediately.</li> </ul>"},{"location":"middleware/overview/#common-use-cases-for-middleware","title":"Common Use Cases for Middleware","text":"<ul> <li>Logging: Recording details about incoming requests and outgoing responses.</li> <li>Authentication/Authorization: Verifying credentials and checking permissions.</li> <li>Error Handling: Catching exceptions from later middleware or handlers and formatting appropriate error responses.</li> <li>Caching: Serving cached responses for certain requests to improve performance.</li> <li>Request/Response Manipulation: Modifying headers, transforming data formats.</li> <li>Validation: Validating incoming data before it reaches core business logic.</li> </ul>"},{"location":"middleware/overview/#defining-middleware-imiddleware","title":"Defining Middleware (<code>IMiddleware</code>)","text":"<p>To create a middleware component, you implement the <code>IMiddleware</code> interface (or more accurately, a class with an <code>async def invoke(self, context, next)</code> method, as Python uses structural subtyping here).</p> <ul> <li><code>context</code>: An object representing the current request or operation. You define the structure of this context object based on your application's needs.</li> <li><code>next</code>: An awaitable callable that invokes the next middleware in the pipeline. You must <code>await next()</code> to pass control to the subsequent middleware. If you don't call it, the pipeline short-circuits at your middleware.</li> </ul> <p>Example of a custom middleware:</p> <pre><code>from wd.di.middleware import IMiddleware # IMiddleware is a type hint helper\n\nclass CustomAuthMiddleware: # Implements IMiddleware structurally\n    async def invoke(self, context, next_middleware):\n        # Example: Assume context has an 'is_authenticated' attribute\n        if not getattr(context, 'is_authenticated', False):\n            # You might raise an error or set a response indicating unauthorized\n            raise PermissionError(\"User not authenticated.\")\n\n        print(\"User is authenticated, proceeding...\")\n\n        # Call the next middleware in the pipeline\n        response = await next_middleware()\n\n        # You can also process the response after it comes back up the chain\n        print(\"CustomAuthMiddleware finished.\")\n        return response\n</code></pre>"},{"location":"middleware/overview/#configuring-the-pipeline","title":"Configuring the Pipeline","text":"<p>WD-DI uses a <code>MiddlewareBuilder</code> (obtained via <code>services.create_application_builder().configure_middleware(...)</code>) to configure the pipeline. You chain <code>use_middleware</code> calls to add middleware components in the desired order of execution.</p> <p>Example:</p> <pre><code>from wd.di import create_service_collection\nfrom wd.di.middleware import LoggingMiddleware # An example built-in\n# from .custom_middleware import CustomAuthMiddleware # Assuming CustomAuthMiddleware is defined\n\n# For demonstration, let's define CustomAuthMiddleware and a dummy context here\nclass CustomAuthMiddleware:\n    async def invoke(self, context, next_middleware):\n        if not getattr(context, 'is_authenticated', False):\n            raise PermissionError(\"User not authenticated.\")\n        print(f\"Auth: User authenticated for path {context.path}\")\n        response = await next_middleware()\n        return response\n\nclass DummyFinalHandler: # Represents the end of your main processing logic\n    async def invoke(self, context, next_middleware): # next_middleware won't be called here\n        print(f\"Handler: Processing context for path {context.path}\")\n        return f\"Successfully processed {context.path}\"\n\nclass RequestContext:\n    def __init__(self, path: str, is_authenticated: bool = False):\n        self.path = path\n        self.is_authenticated = is_authenticated\n\nsc = create_service_collection()\n\n# Create an application builder from the service collection\napp_builder = sc.create_application_builder()\n\n# Configure the middleware pipeline\napp_builder.configure_middleware(lambda builder: (\n    builder\n    .use_middleware(LoggingMiddleware)  # Built-in, assuming it's registered or takes a logger\n    .use_middleware(CustomAuthMiddleware)\n    .use_middleware(DummyFinalHandler) # Your actual request handler might be the last \"middleware\"\n))\n\n# Build the service provider\nprovider = app_builder.build()\n\n# Get the configured middleware pipeline\n# The pipeline itself is registered as a service\nfrom wd.di.middleware import MiddlewarePipeline \npipeline = provider.get_service(MiddlewarePipeline)\n\n# --- Execute the pipeline ---\n# import asyncio # Required if running top-level await\n\nasync def main():\n    # Example 1: Authenticated request\n    print(\"--- Running Authenticated Request ---\")\n    auth_context = RequestContext(path=\"/secret-data\", is_authenticated=True)\n    try:\n        result_auth = await pipeline.execute(auth_context)\n        print(f\"Pipeline Result (Authenticated): {result_auth}\")\n    except Exception as e:\n        print(f\"Error (Authenticated): {e}\")\n\n    print(\"\\\\n--- Running Unauthenticated Request ---\")\n    # Example 2: Unauthenticated request\n    unauth_context = RequestContext(path=\"/secret-data\", is_authenticated=False)\n    try:\n        result_unauth = await pipeline.execute(unauth_context)\n        print(f\"Pipeline Result (Unauthenticated): {result_unauth}\")\n    except Exception as e:\n        print(f\"Error (Unauthenticated): {e}\")\n\n# To run this example:\n# asyncio.run(main())\n</code></pre> <p>When <code>pipeline.execute(context)</code> is called, the <code>context</code> object flows through <code>LoggingMiddleware</code>, then <code>CustomAuthMiddleware</code>, and finally <code>DummyFinalHandler</code> (if authentication passes). The order of registration with <code>use_middleware</code> matters.</p>"},{"location":"middleware/overview/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware components themselves can have dependencies, which will be resolved by the DI container when the middleware is created for the pipeline. This allows your middleware to use other services (e.g., a logging service, a configuration service).</p> <p>The <code>MiddlewareBuilder</code> internally uses the <code>ServiceCollection</code> it was created with to build a temporary <code>ServiceProvider</code> to resolve middleware instances each time <code>pipeline.execute()</code> is called. This ensures middleware dependencies are resolved with the correct lifetimes (e.g., scoped dependencies for a scoped pipeline execution).</p> <p>By leveraging the middleware pipeline, you can create clean, modular, and reusable components for handling tasks that span across multiple parts of your application. </p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This section provides a step-by-step guide to building an application with WD-DI.</p> <p>The final implementation can be found in <code>examples\\order_processor</code></p> <ul> <li>Part 1: Domain &amp; Project Structure</li> <li>Part 2: Services &amp; Infrastructure</li> <li>Part 3: Presentation &amp; Wiring </li> </ul>"},{"location":"tutorial/01-domain/","title":"Part 1: Domain & Project Structure","text":""},{"location":"tutorial/01-domain/#design-tutorial-building-an-order-processing-application-with-wd-di","title":"Design Tutorial: Building an Order Processing Application with WD-DI","text":"<p>In this tutorial, we'll build a small order processing application using WD-DI. This guide will demonstrate how to structure your application using dependency injection as the backbone of your architecture. By the end of this tutorial, you'll see how WD-DI helps you achieve separation of concerns, robust configuration management, and a modular, testable codebase.</p>"},{"location":"tutorial/01-domain/#tutorial-introduction","title":"Tutorial Introduction","text":"<p>Dependency injection is a cornerstone of modern software architecture. It enables you to build loosely coupled, maintainable, and testable systems by decoupling the creation of objects from their usage. In this tutorial, we'll use WD-DI to build an Order Processing application that demonstrates:</p> <ul> <li>Separation of concerns via layered architecture.</li> <li>Interface-driven design to allow for flexibility and easy testing.</li> <li>Robust configuration management using strongly-typed options.</li> <li>Middleware pipelines for cross-cutting concerns (optional extension).</li> <li>Proper management of service lifetimes (transient, singleton, and scoped).</li> </ul>"},{"location":"tutorial/01-domain/#application-overview","title":"Application Overview","text":"<p>Our sample application, OrderProcessor, will:</p> <ul> <li>Accept and process an order.</li> <li>Validate and save the order.</li> <li>Notify the user via email.</li> <li>Log key actions throughout the process.</li> </ul>"},{"location":"tutorial/01-domain/#project-structure","title":"Project Structure","text":"<p>For clarity, our project is organized as follows. This tutorial series will guide you through creating the components within these conceptual directories.</p> <pre><code>order_processor/\n\u251c\u2500\u2500 main.py                 # Application entry point (covered in Part 3)\n\u251c\u2500\u2500 domain/                 # (Covered in this Part - 01-domain.md)\n\u2502   \u251c\u2500\u2500 models.py           # Domain models (e.g., Order)\n\u2502   \u2514\u2500\u2500 interfaces.py       # Domain interfaces (e.g., IOrderService)\n\u251c\u2500\u2500 data/                   # (Covered in Part 2 - 02-services.md)\n\u2502   \u2514\u2500\u2500 repository.py       # Data access implementation\n\u251c\u2500\u2500 services/               # (Covered in Part 2 - 02-services.md)\n\u2502   \u2514\u2500\u2500 order_service.py    # Business logic implementation\n\u251c\u2500\u2500 presentation/           # (Covered in Part 3 - 03-wiring.md)\n\u2502   \u2514\u2500\u2500 controller.py       # Application controller (simulated CLI)\n\u2514\u2500\u2500 infrastructure/         # (Covered in Part 2 - 02-services.md)\n    \u251c\u2500\u2500 config.py           # Configuration classes\n    \u2514\u2500\u2500 logging_service.py  # Logging service implementation\n</code></pre> <p>Note: The original <code>_old_docs/design_tutorial.md</code> file from which this structure is adapted will be removed as its content is fully migrated.</p>"},{"location":"tutorial/01-domain/#tutorial-step-1-domain-and-project-structure","title":"Tutorial - Step 1: Domain and Project Structure","text":"<p>Setting up the domain models and project layout for the order processing application. </p>"},{"location":"tutorial/01-domain/#tutorial-part-1-domain-layer","title":"Tutorial Part 1: Domain Layer","text":"<p>In our Order Processing application, the Domain Layer defines the core business entities and the contracts (interfaces) for how these entities are handled. It should be independent of specific data storage mechanisms or business logic implementations.</p>"},{"location":"tutorial/01-domain/#key-components","title":"Key Components","text":"<ul> <li>Models: Dataclasses or simple classes representing your business entities.</li> <li>Interfaces: Abstract Base Classes (ABCs) defining the expected operations for services and repositories that will interact with these models.</li> </ul>"},{"location":"tutorial/01-domain/#defining-the-order-model","title":"Defining the Order Model","text":"<p>First, let's define our primary business entity, the <code>Order</code>.</p> <p>File: <code>domain/models.py</code> (Conceptual path for the tutorial)</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Order:\n    order_id: str\n    item: str\n    quantity: int\n    price: float\n    # You could add customer_id, status, created_at, etc.\n</code></pre> <p>This simple dataclass will hold information about an order.</p>"},{"location":"tutorial/01-domain/#defining-domain-interfaces","title":"Defining Domain Interfaces","text":"<p>Next, we define the interfaces for services that will operate on our domain models. These interfaces will be implemented by other layers (like the Data Access Layer or Service Layer).</p> <p>File: <code>domain/interfaces.py</code> (Conceptual path for the tutorial)</p> <pre><code>from abc import ABC, abstractmethod\nfrom .models import Order # Assuming models.py is in the same conceptual directory\n\nclass IOrderRepository(ABC):\n    \"\"\"Interface for data persistence operations related to Orders.\"\"\"\n    @abstractmethod\n    def save_order(self, order: Order):\n        pass\n\n    @abstractmethod\n    def get_order_by_id(self, order_id: str) -&gt; Order | None:\n        pass\n\nclass IOrderService(ABC):\n    \"\"\"Interface for business logic related to processing Orders.\"\"\"\n    @abstractmethod\n    def process_new_order(self, order: Order) -&gt; bool:\n        \"\"\"Processes a new order and returns True if successful.\"\"\"\n        pass\n\nclass ILogger(ABC):\n    \"\"\"A generic logger interface for infrastructure concerns.\"\"\"\n    @abstractmethod\n    def log_info(self, message: str):\n        pass\n\n    @abstractmethod\n    def log_error(self, message: str, exception: Exception | None = None):\n        pass\n</code></pre> <p>In this step, we've laid the groundwork by defining what our application deals with (<code>Order</code>) and what operations we expect to perform (<code>IOrderRepository</code>, <code>IOrderService</code>, and a utility <code>ILogger</code>). These interfaces ensure that our business logic (which will use <code>IOrderService</code>) and data access (which will implement <code>IOrderRepository</code>) are decoupled.</p> <p>In the next part, we'll look at implementing these interfaces. </p>"},{"location":"tutorial/02-services/","title":"Tutorial Part 2: Services and Infrastructure","text":"<p>In this part of the tutorial, we'll implement the interfaces defined in the Domain Layer (<code>01-domain.md</code>) and set up basic infrastructure components like logging and configuration placeholders. We'll focus on the Data Access Layer, Service Layer (Business Logic), and Infrastructure Layer.</p> <p>We assume you have an instance of <code>ServiceCollection</code> available, created via <code>sc = create_service_collection()</code> from <code>wd.di</code>.</p>"},{"location":"tutorial/02-services/#infrastructure-layer","title":"Infrastructure Layer","text":"<p>Let's start with some basic infrastructure components. These often include logging, configuration models, or clients for external services.</p> <p>File: <code>infrastructure/logging_service.py</code> (Conceptual)</p> <pre><code># For the tutorial, we'll use interfaces defined in 01-domain.md\n# from domain.interfaces import ILogger \n\n# Assume sc is an instance of ServiceCollection from wd.di\n# from wd.di import create_service_collection\n# sc = create_service_collection() \n\n# @sc.singleton(ILogger) # Registering the concrete logger\nclass ConsoleLogger: # Implements ILogger structurally for simplicity here\n    def log_info(self, message: str):\n        print(f\"[INFO] {message}\")\n\n    def log_error(self, message: str, exception: Exception | None = None):\n        if exception:\n            print(f\"[ERROR] {message} - Exception: {exception}\")\n        else:\n            print(f\"[ERROR] {message}\")\n</code></pre> <p>File: <code>infrastructure/config_models.py</code> (Conceptual)</p> <p><pre><code>from dataclasses import dataclass\n\n@dataclass\nclass AppConfig:\n    \"\"\"Represents application-level configuration settings.\"\"\"\n    service_name: str = \"OrderProcessorTutorial\"\n    default_user: str = \"system\"\n    debug_mode: bool = False\n\n@dataclass\nclass EmailServiceOptions:\n    \"\"\"Configuration specific to an email service.\"\"\"\n    smtp_host: str = \"localhost\"\n    smtp_port: int = 2525 # Default for MailHog/MailCatcher\n    sender_address: str = \"noreply@example.com\"\n</code></pre> These dataclasses will be used with WD-DI's Options pattern later when we wire everything up.</p>"},{"location":"tutorial/02-services/#data-access-layer-dal","title":"Data Access Layer (DAL)","text":"<p>This layer is responsible for data persistence. It implements the repository interfaces defined in the Domain Layer.</p> <p>File: <code>data/repository.py</code> (Conceptual)</p> <p><pre><code># Using interfaces from domain.interfaces (see 01-domain.md)\n# from domain.interfaces import IOrderRepository, ILogger, Order\n# from infrastructure.logging_service import ConsoleLogger # Or inject ILogger\n\n# Assume sc is an instance of ServiceCollection\n# from wd.di import create_service_collection\n# sc = create_service_collection()\n\n# @sc.singleton(IOrderRepository)\nclass InMemoryOrderRepository: # Implements IOrderRepository structurally\n    def __init__(self, logger: /*ILogger from domain.interfaces*/ object):\n        self._logger = logger\n        self._orders_db = {}\n        self._logger.log_info(\"InMemoryOrderRepository initialized.\")\n\n    def save_order(self, order: /*Order from domain.models*/ object):\n        self._logger.log_info(f\"DAL: Saving order {order.order_id}\")\n        self._orders_db[order.order_id] = order\n        self._logger.log_info(f\"DAL: Order {order.order_id} saved.\")\n\n    def get_order_by_id(self, order_id: str) -&gt; /*Order | None from domain.models*/ object | None:\n        self._logger.log_info(f\"DAL: Attempting to retrieve order {order_id}\")\n        order = self._orders_db.get(order_id)\n        if order:\n            self._logger.log_info(f\"DAL: Order {order_id} found.\")\n        else:\n            self._logger.log_info(f\"DAL: Order {order_id} not found.\")\n        return order\n</code></pre> For this tutorial, <code>InMemoryOrderRepository</code> uses a simple dictionary as an in-memory database. It depends on <code>ILogger</code> (which <code>ConsoleLogger</code> implements) for logging its actions.</p>"},{"location":"tutorial/02-services/#service-layer-business-logic","title":"Service Layer (Business Logic)","text":"<p>This layer contains the core business logic of the application. It orchestrates operations using services from the Data Access Layer and other business services.</p> <p>File: <code>services/order_processing_service.py</code> (Conceptual)</p> <p><pre><code># Using interfaces and models from domain (see 01-domain.md)\n# from domain.interfaces import IOrderService, IOrderRepository, ILogger, Order\n# from infrastructure.logging_service import ConsoleLogger # Or inject ILogger\n\n# Assume sc is an instance of ServiceCollection\n# from wd.di import create_service_collection\n# sc = create_service_collection()\n\n# @sc.singleton(IOrderService)\nclass OrderProcessingService: # Implements IOrderService structurally\n    def __init__(self, \n                 order_repository: /*IOrderRepository*/ object, \n                 logger: /*ILogger*/ object):\n        self._order_repository = order_repository\n        self._logger = logger\n        self._logger.log_info(\"OrderProcessingService initialized.\")\n\n    def process_new_order(self, order: /*Order from domain.models*/ object) -&gt; bool:\n        self._logger.log_info(f\"SERVICE: Processing new order {order.order_id} for item '{order.item}'\")\n\n        # Basic validation (example)\n        if order.quantity &lt;= 0 or order.price &lt;= 0:\n            self._logger.log_error(f\"SERVICE: Invalid order data for {order.order_id}. Quantity/Price must be positive.\")\n            return False\n\n        # Simulate some processing, e.g., payment, inventory check (not shown)\n        self._logger.log_info(f\"SERVICE: Order {order.order_id} passed validation and pre-processing.\")\n\n        try:\n            self._order_repository.save_order(order)\n            self._logger.log_info(f\"SERVICE: Order {order.order_id} successfully saved by repository.\")\n            # Here you might trigger notifications, update other systems, etc.\n            return True\n        except Exception as e:\n            self._logger.log_error(f\"SERVICE: Failed to save order {order.order_id}\", exception=e)\n            return False\n</code></pre> The <code>OrderProcessingService</code> implements <code>IOrderService</code>. It depends on an <code>IOrderRepository</code> to save order data and an <code>ILogger</code> for logging. Its <code>process_new_order</code> method contains the (simplified) business logic for handling a new order.</p> <p>In the next part, we'll create the Presentation Layer and wire all these components together using WD-DI.</p> <p>(Note: For actual type hints like <code>/*ILogger from domain.interfaces*/ object</code>, you would use the real imported types. The comments are for illustrative cross-referencing to <code>01-domain.md</code> within this markdown context.) </p>"},{"location":"tutorial/03-wiring/","title":"Tutorial Part 3: Presentation and Wiring It All Up","text":"<p>In this final part of the tutorial, we'll create the Presentation Layer for our Order Processing application and then wire all the components (Domain, Services, Infrastructure, Presentation) together using WD-DI. This will demonstrate how to configure and run the application.</p> <p>We assume you have an instance of <code>ServiceCollection</code> available, created via <code>sc = create_service_collection()</code> from <code>wd.di</code>.</p>"},{"location":"tutorial/03-wiring/#presentation-layer","title":"Presentation Layer","text":"<p>This layer provides the interface to interact with your application. For this tutorial, we'll simulate a simple command-line interface (CLI) interaction point using an <code>OrderController</code>.</p> <p>File: <code>presentation/controller.py</code> (Conceptual)</p> <p><pre><code># Using Order from domain.models and IOrderService from domain.interfaces (see 01-domain.md)\n# from domain.models import Order \n# from domain.interfaces import IOrderService\n\n# Assume sc is an instance of ServiceCollection\n# from wd.di import create_service_collection\n# sc = create_service_collection()\n\n# @sc.transient() # Controllers are often transient or scoped\nclass OrderController:\n    def __init__(self, order_service: /*IOrderService from domain.interfaces*/ object):\n        self.order_service = order_service\n\n    def submit_order_cli(self, order_id: str, item: str, quantity: int, price: float):\n        print(f\"CLI: Received order submission for ID: {order_id}\")\n        # In a real CLI, you'd parse arguments here\n        # Create the Order model instance\n        order_data = { \"order_id\": order_id, \"item\": item, \"quantity\": quantity, \"price\": price } # Using dict for Order model for simplicity here.\n                                                                                                 # Ideally, Order class would be imported and used.\n        # Simulate creating an Order object; in a real app, import Order from domain.models\n        class TempOrder: # Placeholder for domain.models.Order\n            def __init__(self, order_id, item, quantity, price):\n                self.order_id = order_id\n                self.item = item\n                self.quantity = quantity\n                self.price = price\n\n        actual_order = TempOrder(order_id=order_id, item=item, quantity=quantity, price=price)\n\n        success = self.order_service.process_new_order(actual_order)\n        if success:\n            print(f\"CLI: Order {order_id} processed successfully by the service.\")\n        else:\n            print(f\"CLI: Order {order_id} processing failed.\")\n</code></pre> The <code>OrderController</code> depends on <code>IOrderService</code> to delegate the actual order processing.</p>"},{"location":"tutorial/03-wiring/#wiring-it-all-up-with-wd-di","title":"Wiring It All Up with WD-DI","text":"<p>Now, let's bring all the pieces together in a <code>main.py</code> file. This is where we will: 1.  Create a <code>ServiceCollection</code>. 2.  Register all our services (Logger, Repository, Order Service, Controller). 3.  Configure options (like <code>AppConfig</code>). 4.  Build the <code>ServiceProvider</code>. 5.  Resolve the <code>OrderController</code> and simulate an order submission.</p> <p>File: <code>main.py</code> (Application Entry Point)</p> <pre><code>from wd.di import create_service_collection\nfrom wd.di.config import Configuration, Options, IConfiguration\n\n# Assume these are your actual defined classes from the tutorial modules\n# (domain/interfaces.py, domain/models.py)\n# (infrastructure/logging_service.py, infrastructure/config_models.py)\n# (data/repository.py, services/order_processing_service.py, presentation/controller.py)\n\n# --- 0. Define/Import interfaces and models (from Tutorial Part 1: 01-domain.md) ---\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n@dataclass\nclass Order:\n    order_id: str\n    item: str\n    quantity: int\n    price: float\n\nclass IOrderRepository(ABC):\n    @abstractmethod\n    def save_order(self, order: Order):\n        pass\n    @abstractmethod\n    def get_order_by_id(self, order_id: str) -&gt; Order | None:\n        pass\n\nclass IOrderService(ABC):\n    @abstractmethod\n    def process_new_order(self, order: Order) -&gt; bool:\n        pass\n\nclass ILogger(ABC):\n    @abstractmethod\n    def log_info(self, message: str):\n        pass\n    @abstractmethod\n    def log_error(self, message: str, exception: Exception | None = None):\n        pass\n\n# --- 1. Create ServiceCollection ---\nsc = create_service_collection()\n\n# --- 2. Implementations (from Tutorial Part 2: 02-services.md and Presentation Layer) ---\n\n# Infrastructure Layer\n@dataclass\nclass AppConfig:\n    service_name: str = \"OrderProcessorTutorial\"\n    default_user: str = \"system\"\n    debug_mode: bool = False\n\n@sc.singleton(ILogger)\nclass ConsoleLogger(ILogger):\n    def log_info(self, message: str):\n        print(f\"[INFO] {message}\")\n    def log_error(self, message: str, exception: Exception | None = None):\n        err_msg = f\"[ERROR] {message}\"\n        if exception:\n            err_msg += f\" - Exception: {type(exception).__name__}: {exception}\"\n        print(err_msg)\n\n# Data Access Layer\n@sc.singleton(IOrderRepository)\nclass InMemoryOrderRepository(IOrderRepository):\n    def __init__(self, logger: ILogger):\n        self._logger = logger\n        self._orders_db: dict[str, Order] = {}\n        self._logger.log_info(\"InMemoryOrderRepository initialized.\")\n\n    def save_order(self, order: Order):\n        self._logger.log_info(f\"DAL: Saving order {order.order_id}\")\n        self._orders_db[order.order_id] = order\n        self._logger.log_info(f\"DAL: Order {order.order_id} saved.\")\n\n    def get_order_by_id(self, order_id: str) -&gt; Order | None:\n        self._logger.log_info(f\"DAL: Attempting to retrieve order {order_id}\")\n        order = self._orders_db.get(order_id)\n        if order:\n            self._logger.log_info(f\"DAL: Order {order_id} found.\")\n        else:\n            self._logger.log_info(f\"DAL: Order {order_id} not found.\")\n        return order\n\n# Service Layer\n@sc.singleton(IOrderService)\nclass OrderProcessingService(IOrderService):\n    def __init__(self, order_repository: IOrderRepository, logger: ILogger):\n        self._order_repository = order_repository\n        self._logger = logger\n        self._logger.log_info(\"OrderProcessingService initialized.\")\n\n    def process_new_order(self, order: Order) -&gt; bool:\n        self._logger.log_info(f\"SERVICE: Processing new order {order.order_id} for item '{order.item}'\")\n        if order.quantity &lt;= 0 or order.price &lt;= 0:\n            self._logger.log_error(f\"SERVICE: Invalid order data for {order.order_id}.\")\n            return False\n        self._logger.log_info(f\"SERVICE: Order {order.order_id} passed validation.\")\n        try:\n            self._order_repository.save_order(order)\n            self._logger.log_info(f\"SERVICE: Order {order.order_id} successfully saved.\")\n            return True\n        except Exception as e:\n            self._logger.log_error(f\"SERVICE: Failed to save order {order.order_id}\", exception=e)\n            return False\n\n# Presentation Layer\n@sc.transient() # Controllers are often transient or scoped\nclass OrderController:\n    def __init__(self, order_service: IOrderService, logger: ILogger, app_config_options: Options[AppConfig]):\n        self.order_service = order_service\n        self.logger = logger\n        self.app_config = app_config_options.value # Access the AppConfig instance\n        self.logger.log_info(f\"OrderController initialized for service: {self.app_config.service_name}\")\n\n    def submit_order_cli(self, order_id: str, item: str, quantity: int, price: float):\n        self.logger.log_info(f\"CLI: Received order submission for ID: {order_id} by {self.app_config.default_user}\")\n        order_data = Order(order_id=order_id, item=item, quantity=quantity, price=price)\n        success = self.order_service.process_new_order(order_data)\n        if success:\n            self.logger.log_info(f\"CLI: Order {order_id} processed successfully.\")\n        else:\n            self.logger.log_error(f\"CLI: Order {order_id} processing failed.\")\n\n# --- 3. Configure Options ---\napp_config_dict = {\n    \"App\": {\n        \"ServiceName\": \"MyAwesomeOrderProcessor\",\n        \"DefaultUser\": \"TutorialUser\",\n        \"DebugMode\": True\n    }\n}\nconfig_source = Configuration(app_config_dict)\nsc.add_singleton_factory(IConfiguration, lambda _: config_source) # Register IConfiguration\nsc.configure(AppConfig, section=\"App\") # Configure AppConfig to bind to \"App\" section\n\n# --- 4. Build ServiceProvider ---\nprovider = sc.build_service_provider()\n\n# --- 5. Resolve and Use ---\nif __name__ == \"__main__\":\n    main_logger = provider.get_service(ILogger)\n    main_logger.log_info(\"Application starting...\")\n\n    controller = provider.get_service(OrderController)\n\n    # Simulate submitting a valid order\n    controller.submit_order_cli(order_id=\"ORD001\", item=\"Laptop\", quantity=1, price=1200.50)\n\n    # Simulate submitting an invalid order\n    controller.submit_order_cli(order_id=\"ORD002\", item=\"Mouse\", quantity=0, price=25.00)\n\n    main_logger.log_info(\"Application finished.\")\n\n---\n\n## Running the Application\n\nTo run the `main.py` script developed in this tutorial (which includes all the defined services, interfaces, and the controller), you would typically execute it directly:\n\n```bash\npython main.py \n# Ensure main.py is in your current directory or provide the correct path.\n</code></pre> <p>Upon execution, you should see output similar to the following, demonstrating the logger in action and the flow of the order processing:</p> <pre><code>[INFO] ConsoleLogger initialized.\n[INFO] InMemoryOrderRepository initialized.\n[INFO] OrderProcessingService initialized.\n[INFO] OrderController initialized for service: MyAwesomeOrderProcessor\n[INFO] CLI: Received order submission for ID: order123 by TutorialUser\n[INFO] SERVICE: Processing new order order123 for item 'Laptop'\n[INFO] SERVICE: Order order123 passed validation.\n[INFO] DAL: Saving order order123\n[INFO] DAL: Order order123 saved.\n[INFO] SERVICE: Order order123 successfully saved.\n[INFO] CLI: Order order123 processed successfully.\n</code></pre> <p>This output confirms that: - Services were initialized as expected (ConsoleLogger, InMemoryOrderRepository, OrderProcessingService, OrderController). - Configuration (AppConfig with <code>ServiceName</code> and <code>DefaultUser</code>) was loaded and used by the <code>OrderController</code>. - The <code>OrderController</code> successfully invoked the <code>OrderProcessingService</code>. - The <code>OrderProcessingService</code> interacted with the <code>InMemoryOrderRepository</code>. - Logging messages were produced at each significant step by the <code>ConsoleLogger</code>.</p>"},{"location":"tutorial/03-wiring/#tutorial-conclusion","title":"Tutorial Conclusion","text":"<p>In this tutorial, we've built a simple order processing application that demonstrates how to:</p> <ul> <li>Separate concerns by splitting the application into distinct layers (Domain, Data Access, Services, Presentation, Infrastructure).</li> <li>Design using interfaces (like <code>ILogger</code>, <code>IOrderRepository</code>, <code>IOrderService</code>) and concrete implementations to achieve a flexible, testable codebase.</li> <li>Manage configuration through strongly-typed options (<code>AppConfig</code> bound from a dictionary).</li> <li>Leverage WD-DI to wire all components together, using <code>create_service_collection()</code> and decorators like <code>@sc.singleton()</code> and <code>@sc.transient()</code> for registering services and managing their lifetimes.</li> </ul> <p>By using WD-DI, you not only simplify dependency management but also establish a solid foundation for building scalable and maintainable Python applications. This design tutorial illustrates that dependency injection is far more than a theoretical concept\u2014it's a practical tool for crafting high-quality software architectures.</p>"}]}